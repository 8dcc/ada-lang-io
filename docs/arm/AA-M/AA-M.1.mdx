---
sidebar_position:  211
---

# M.1 Specific Documentation Requirements

:::warning
We're still working on the Reference manual output.  Internal links are broken,
as are a bunch of other things.
See the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

<p>{"{"}<em>{"AI12-0442-1"}</em>{"}"} In addition to implementation-defined characteristics, each Ada implementation is required to document various properties of the implementation: </p>
<Admonition type="note">
<p><strong>Ramification: </strong>Most of the items in this list require documentation only for implementations that conform to Specialized Needs Annexes. </p></Admonition>

<p>The behavior of implementations in implementation-defined situations shall be documented - see M.2, "Implementation-Defined Characteristics" for a listing. See 1.1.1(77).</p>
<p>The set of values that a user-defined Allocate procedure needs to accept for the Alignment parameter. How the standard storage pool is chosen, and how storage is allocated by standard storage pools. See 13.11(23).</p>
<p>The algorithm used for random number generation, including a description of its period. See A.5.2(44).</p>
<p>The minimum time interval between calls to the time-dependent Reset procedure that is guaranteed to initiate different random number sequences. See A.5.2(45).</p>
<p>The conditions under which Io_Exceptions.Name_Error, Io_Exceptions.Use_Error, and Io_Exceptions.Device_Error are propagated. See A.13(15).</p>
<p>The behavior of package Environment_Variables when environment variables are changed by external mechanisms. See A.17(30/2).</p>
<p>The overhead of calling machine-code or intrinsic subprograms. See C.1(6).</p>
<p>The types and attributes used in machine code insertions. See C.1(7).</p>
<p>The subprogram calling conventions for all supported convention identifiers. See C.1(8/3).</p>
<p>The mapping between the Link_Name or Ada designator and the external link name. See C.1(9).</p>
<p>The treatment of interrupts. See C.3(22).</p>
<p>The metrics for interrupt handlers. See C.3.1(16).</p>
<p>If the Ceiling_Locking policy is in effect, the default ceiling priority for a protected object that specifies an interrupt handler aspect. See C.3.2(24/5).</p>
<p>Any circumstances when the elaboration of a preelaborated package causes code to be executed. See C.4(12).</p>
<p>Whether a partition can be restarted without reloading. See C.4(13).</p>
<p>The effect of calling Current_Task from an entry body or interrupt handler. See C.7.1(19).</p>
<p>For package Task_Attributes, limits on the number and size of task attributes, and how to configure any limits. See C.7.2(19).</p>
<p>The metrics for the Task_Attributes package. See C.7.2(27).</p>
<p>The details of the configuration used to generate the values of all metrics. See D(2).</p>
<p>The maximum priority inversion a user task can experience from the implementation. See D.2.3(12/2).</p>
<p>The amount of time that a task can be preempted for processing on behalf of lower-priority tasks. See D.2.3(13/2).</p>
<p>The quantum values supported for round robin dispatching. See D.2.5(16/2).</p>
<p>The accuracy of the detection of the exhaustion of the budget of a task for round robin dispatching. See D.2.5(17/2).</p>
<p>Any conditions that cause the completion of the setting of the deadline of a task to be delayed for a multiprocessor. See D.2.6(32/2).</p>
<p>Any conditions that cause the completion of the setting of the priority of a task to be delayed for a multiprocessor. See D.5.1(12.1/2).</p>
<p>The metrics for Set_Priority. See D.5.1(14).</p>
<p>The metrics for setting the priority of a protected object. See D.5.2(10).</p>
<p>On a multiprocessor, any conditions that cause the completion of an aborted construct to be delayed later than what is specified for a single processor. See D.6(3).</p>
<p>The metrics for aborts. See D.6(8).</p>
<p>The values of Time_First, Time_Last, Time_Span_First, Time_Span_Last, Time_Span_Unit, and Tick for package Real_Time. See D.8(33).</p>
<p>The properties of the underlying time base used in package Real_Time. See D.8(34).</p>
<p>Any synchronization of package Real_Time with external time references. See D.8(35).</p>
<p>Any aspects of the external environment that can interfere with package Real_Time. See D.8(36/5).</p>
<p>The metrics for package Real_Time. See D.8(45).</p>
<p>The minimum value of the delay expression of a <code><a href="../AA-9/AA-9.6#S0268">delay_relative_statement</a></code> that causes a task to actually be blocked. See D.9(7).</p>
<p>The minimum difference between the value of the delay expression of a <code><a href="../AA-9/AA-9.6#S0267">delay_until_statement</a></code> and the value of Real_Time.Clock, that causes the task to actually be blocked. See D.9(8).</p>
<p>The metrics for delay statements. See D.9(13).</p>
<p>The upper bound on the duration of interrupt blocking caused by the implementation. See D.12(5).</p>
<p>The metrics for entry-less protected objects. See D.12(12).</p>
<p>The values of CPU_Time_First, CPU_Time_Last, CPU_Time_Unit, and CPU_Tick of package Execution_Time. See D.14(21/2).</p>
<p>The properties of the mechanism used to implement package Execution_Time, including the values of the constants defined in the package. See D.14(22/2).</p>
<p>The metrics for execution time. See D.14(27).</p>
<p>The metrics for timing events. See D.15(24).</p>
<p>The processor(s) on which the clock interrupt is handled; the processors on which each Interrupt_Id can be handled. See D.16.1(32).</p>
<p>Whether the RPC-receiver is invoked from concurrent tasks, and if so, the number of such tasks. See E.5(25).</p>
<p>Any techniques used to reduce cancellation errors in Numerics.Generic_Real_Arrays shall be documented. See G.3.1(86/2).</p>
<p>Any techniques used to reduce cancellation errors in Numerics.Generic_Complex_Arrays shall be documented. See G.3.2(155/2).</p>
<p>If a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Normalize_Scalars applies, the implicit initial values of scalar subtypes shall be documented. Such a value should be an invalid representation when possible; any cases when is it not shall be documented. See H.1(5/2).</p>
<p>The range of effects for each bounded error and each unspecified effect. If the effects of a given erroneous construct are constrained, the constraints shall be documented. See H.2(1).</p>
<p>For each inspection point, a mapping between each inspectable object and the machine resources where the object's value can be obtained shall be provided. See H.3.2(8).</p>
<p>If a pragma Restrictions(No_Exceptions) is specified, the effects of all constructs where language-defined checks are still performed. See H.4(25).</p>
<p>The interrupts to which a task entry may be attached. See J.7.1(12).</p>
<p>The type of entry call invoked for an interrupt entry. See J.7.1(13).</p>
