---
sidebar_position:  121
---

# A.4 String Handling

:::warning
We're still working on the Reference manual output.  Internal links are broken,
as are a bunch of other things.
See the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI05-0299-1"}</em>{"}"} This subclause presents the specifications of the package Strings and several child packages, which provide facilities for dealing with string data. Fixed-length, bounded-length, and unbounded-length strings are supported, for String, Wide_String, and Wide_Wide_String. The string-handling subprograms include searches for pattern strings and for characters in program-specified sets, translation (via a character-to-character mapping), and transformation (replacing, inserting, overwriting, and deleting of substrings). </p>

#### Extensions to Ada 83

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0299-1"}</em>{"}"} This subclause is new to Ada 95. </p></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} Included Wide_Wide_String in this description; the individual changes are documented as extensions as needed. </p></Admonition>


## A.4.1  The Package Strings

<p>The package Strings provides declarations common to the string handling packages. </p>

#### Static Semantics

<p>The library package Strings has the following declaration: </p>
<CodeBlock>
{"{"}{"AI12-0414-1"}{"}"} package Ada.Strings{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00285-01"}{"}"}    Space      : constant Character      := ' ';{"\n"}   Wide_Space : constant Wide_Character := ' ';{"\n"}   Wide_Wide_Space : constant Wide_Wide_Character := ' ';{"\n"}
</CodeBlock>

<CodeBlock>
   Length_Error, Pattern_Error, Index_Error, Translation_Error : exception;{"\n"}
</CodeBlock>

<CodeBlock>
   type Alignment  is (Left, Right, Center);{"\n"}   type Truncation is (Left, Right, Error);{"\n"}   type Membership is (Inside, Outside);{"\n"}   type Direction  is (Forward, Backward);{"\n"}   type Trim_End   is (Left, Right, Both);{"\n"}end Ada.Strings;{"\n"}
</CodeBlock>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI05-0005-1"}</em>{"}"} Constant Wide_Wide_Space is added to Ada.Strings. If Ada.Strings is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> of Wide_Wide_Space is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


## A.4.2  The Package Strings.Maps

<p>{"{"}<em>{"AI12-0445-1"}</em>{"}"} The package Strings.Maps defines the types, operations, and other entities necessary for character sets and character-to-character mappings. </p>

#### Static Semantics

<p>The library package Strings.Maps has the following declaration: </p>
<CodeBlock>
{"{"}{"AI95-00362-01"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.Maps{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00161-01"}{"}"} {"{"}{"AI12-0399-1"}{"}"}    -- Representation for a set of character values:{"\n"}   type Character_Set is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   Null_Set : constant Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   type Character_Range is{"\n"}     record{"\n"}        Low  : Character;{"\n"}        High : Character;{"\n"}     end record;{"\n"}   -- Represents Character range Low..High{"\n"}
</CodeBlock>

<CodeBlock>
   type Character_Ranges is array (Positive range {"<"}{">"}) of Character_Range;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set    (Ranges : in Character_Ranges)return Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set    (Span   : in Character_Range)return Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Ranges (Set    : in Character_Set)  return Character_Ranges;{"\n"}
</CodeBlock>

<CodeBlock>
   function "="   (Left, Right : in Character_Set) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "not" (Right : in Character_Set)       return Character_Set;{"\n"}   function "and" (Left, Right : in Character_Set) return Character_Set;{"\n"}   function "or"  (Left, Right : in Character_Set) return Character_Set;{"\n"}   function "xor" (Left, Right : in Character_Set) return Character_Set;{"\n"}   function "-"   (Left, Right : in Character_Set) return Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_In (Element : in Character;{"\n"}                   Set     : in Character_Set){"\n"}      return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_Subset (Elements : in Character_Set;{"\n"}                       Set      : in Character_Set){"\n"}      return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}=" (Left  : in Character_Set;{"\n"}                  Right : in Character_Set){"\n"}      return Boolean renames Is_Subset;{"\n"}
</CodeBlock>

<CodeBlock>
   -- Alternative representation for a set of character values:{"\n"}   subtype Character_Sequence is String;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Sequence  : in Character_Sequence)return Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Singleton : in Character)     return Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Sequence (Set  : in Character_Set) return Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00161-01"}{"}"} {"{"}{"AI12-0399-1"}{"}"}    -- Representation for a character to character mapping:{"\n"}   type Character_Mapping is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   function Value (Map     : in Character_Mapping;{"\n"}                   Element : in Character){"\n"}      return Character;{"\n"}
</CodeBlock>

<CodeBlock>
   Identity : constant Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Mapping (From, To : in Character_Sequence){"\n"}      return Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Domain (Map : in Character_Mapping){"\n"}      return Character_Sequence;{"\n"}   function To_Range  (Map : in Character_Mapping){"\n"}      return Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
   type Character_Mapping_Function is{"\n"}      access function (From : in Character) return Character;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Maps;{"\n"}
</CodeBlock>

<p>An object of type Character_Set represents a set of characters.</p>
<p>Null_Set represents the set containing no characters.</p>
<p>An object Obj of type Character_Range represents the set of characters in the range Obj.Low .. Obj.High.</p>
<p>An object Obj of type Character_Ranges represents the union of the sets corresponding to Obj(I) for I in Obj'Range. </p>
<CodeBlock>
function To_Set (Ranges : in Character_Ranges) return Character_Set;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} If Ranges'Length=0 then Null_Set is returned; otherwise, the returned value represents the set corresponding to Ranges.</p>
<CodeBlock>
function To_Set (Span : in Character_Range) return Character_Set;{"\n"}
</CodeBlock>

<p>The returned value represents the set containing each character in Span. </p>
<CodeBlock>
function To_Ranges (Set : in Character_Set) return Character_Ranges;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} If Set = Null_Set, then an empty Character_Ranges array is returned; otherwise, the shortest array of contiguous ranges of Character values in Set, in increasing order of Low, is returned.</p>
<CodeBlock>
function "=" (Left, Right : in Character_Set) return Boolean;{"\n"}
</CodeBlock>

<p>The function "=" returns True if Left and Right represent identical sets, and False otherwise. </p>
<p>Each of the logical operators "<strong>not</strong>", "<strong>and</strong>", "<strong>or</strong>", and "<strong>xor</strong>" returns a Character_Set value that represents the set obtained by applying the corresponding operation to the set(s) represented by the parameter(s) of the operator. ""(Left, Right) is equivalent to "and"(Left, "not"(Right)). </p>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>The set minus operator is provided for efficiency.</p></Admonition>

<CodeBlock>
function Is_In (Element : in Character;{"\n"}                Set     : in Character_Set);{"\n"}   return Boolean;{"\n"}
</CodeBlock>

<p>Is_In returns True if Element is in Set, and False otherwise.</p>
<CodeBlock>
function Is_Subset (Elements : in Character_Set;{"\n"}                    Set      : in Character_Set){"\n"}   return Boolean;{"\n"}
</CodeBlock>

<p>Is_Subset returns True if Elements is a subset of Set, and False otherwise.</p>
<CodeBlock>
subtype Character_Sequence is String;{"\n"}
</CodeBlock>

<p>The Character_Sequence subtype is used to portray a set of character values and also to identify the domain and range of a character mapping. </p>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>Although a named subtype is redundant - the predefined type String could have been used for the parameter to To_Set and To_Mapping below - the use of a differently named subtype identifies the intended purpose of the parameter. </p></Admonition>

<CodeBlock>
function To_Set (Sequence  : in Character_Sequence) return Character_Set;{"\n"}{"\n"}function To_Set (Singleton : in Character)          return Character_Set;{"\n"}
</CodeBlock>

<p>Sequence portrays the set of character values that it explicitly contains (ignoring duplicates). Singleton portrays the set comprising a single Character. Each of the To_Set functions returns a Character_Set value that represents the set portrayed by Sequence or Singleton.</p>
<CodeBlock>
function To_Sequence (Set : in Character_Set) return Character_Sequence;{"\n"}
</CodeBlock>

<p>The function To_Sequence returns a Character_Sequence value containing each of the characters in the set represented by Set, in ascending order with no duplicates.</p>
<CodeBlock>
type Character_Mapping is private;{"\n"}
</CodeBlock>

<p>An object of type Character_Mapping represents a Character-to-Character mapping.</p>
<CodeBlock>
function Value (Map     : in Character_Mapping;{"\n"}                Element : in Character){"\n"}   return Character;{"\n"}
</CodeBlock>

<p>The function Value returns the Character value to which Element maps with respect to the mapping represented by Map. </p>
<p>A character C <em>matches</em> a pattern character P with respect to a given Character_Mapping value Map if Value(Map, C) = P. A string S <em>matches</em> a pattern string P with respect to a given Character_Mapping if their lengths are the same and if each character in S matches its corresponding character in the pattern string P. </p>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<p><strong></strong>In an earlier version of the string handling packages, the definition of matching was symmetrical, namely C matches P if Value(Map,C) = Value(Map,P). However, applying the mapping to the pattern was confusing according to some reviewers. Furthermore, if the symmetrical version is needed, it can be achieved by applying the mapping to the pattern (via translation) prior to passing it as a parameter. </p></Admonition>

<p>String handling subprograms that deal with character mappings have parameters whose type is Character_Mapping. </p>
<CodeBlock>
Identity : constant Character_Mapping;{"\n"}
</CodeBlock>

<p>Identity maps each Character to itself.</p>
<CodeBlock>
function To_Mapping (From, To : in Character_Sequence){"\n"}    return Character_Mapping;{"\n"}
</CodeBlock>

<p>To_Mapping produces a Character_Mapping such that each element of From maps to the corresponding element of To, and each other character maps to itself. If From'Length /= To'Length, or if some character is repeated in From, then Translation_Error is propagated.</p>
<CodeBlock>
function To_Domain (Map : in Character_Mapping) return Character_Sequence;{"\n"}
</CodeBlock>

<p>To_Domain returns the shortest Character_Sequence value D such that each character not in D maps to itself, and such that the characters in D are in ascending order. The lower bound of D is 1.</p>
<CodeBlock>
function To_Range  (Map : in Character_Mapping) return Character_Sequence;{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0048</em>{"}"} {"{"}<em>{"AI95-00151-01"}</em>{"}"} To_Range returns the Character_Sequence value R, such that if D = To_Domain(Map), then R has the same bounds as D, and D(I) maps to R(I) for each I in D'Range. </p>
<p>An object F of type Character_Mapping_Function maps a Character value C to the Character value F.<strong>all</strong>(C), which is said to <em>match</em> C with respect to mapping function F. </p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 1   Character_Mapping and Character_Mapping_Function are used both for character equivalence mappings in the search subprograms (such as for case insensitivity) and as transformational mappings in the Translate subprograms.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 2   To_Domain(Identity) and To_Range(Identity) each returns the null string. </p></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>Package Strings.Maps is not pure, since it declares an access-to-subprogram type. </p></Admonition>


#### Examples

<p>{"{"}<em>{"AI12-0429-1"}</em>{"}"} <em>Example of use of Strings.Maps.To_Mapping:</em></p>
<p>To_Mapping("ABCD", "ZZAB") returns a Character_Mapping that maps 'A' and 'B' to 'Z', 'C' to 'A', 'D' to 'B', and each other Character to itself. </p>

#### Extensions to Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} <strong>Amendment </strong> Added <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization to types Character_Set and Character_Mapping, so that they can be used to declare default-initialized objects in preelaborated units.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00362-01"}</em>{"}"} Strings.Maps is now Pure, so it can be used in pure units. </p></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>8652/0048</em>{"}"} {"{"}<em>{"AI95-00151-01"}</em>{"}"} <strong>Corrigendum:</strong> Corrected the definition of the range of the result of To_Range, since the Ada 95 definition makes no sense. </p></Admonition>


## A.4.3  Fixed-Length String Handling

<p>The language-defined package Strings.Fixed provides string-handling subprograms for fixed-length strings; that is, for values of type Standard.String. Several of these subprograms are procedures that modify the contents of a String that is passed as an <strong>out</strong> or an <strong>in</strong> <strong>out</strong> parameter; each has additional parameters to control the effect when the logical length of the result differs from the parameter's length.</p>
<p>For each function that returns a String, the lower bound of the returned value is 1. </p>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<p><strong></strong>{"{"}<em>{"AI95-00114-01"}</em>{"}"} Most operations that yield a String are provided both as a function and as a procedure. The functional form is possibly a more aesthetic style but may introduce overhead due to extra copying or dynamic memory usage in some implementations. Thus a procedural form, with an <strong>in</strong> <strong>out</strong> parameter so that all copying is done `in place', is also supplied.</p></Admonition>

<p>The basic model embodied in the package is that a fixed-length string comprises significant characters and possibly padding (with space characters) on either or both ends. When a shorter string is copied to a longer string, padding is inserted, and when a longer string is copied to a shorter one, padding is stripped. The Move procedure in Strings.Fixed, which takes a String as an <strong>out</strong> parameter, allows the programmer to control these effects. Similar control is provided by the string transformation procedures. </p>

#### Static Semantics

<p>The library package Strings.Fixed has the following declaration: </p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Strings.Maps;{"\n"}package Ada.Strings.Fixed{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
</CodeBlock>

<CodeBlock>
-- "Copy" procedure for strings of possibly different lengths{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Move (Source  : in  String;{"\n"}                   Target  : out String;{"\n"}                   Drop    : in  Truncation := Error;{"\n"}                   Justify : in  Alignment  := Left;{"\n"}                   Pad     : in  Character  := Space);{"\n"}
</CodeBlock>

<CodeBlock>
-- Search subprograms{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in String;{"\n"}                   Pattern : in String;{"\n"}                   From    : in Positive;{"\n"}                   Going   : in Direction := Forward;{"\n"}                   Mapping : in Maps.Character_Mapping := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in String;{"\n"}                   Pattern : in String;{"\n"}                   From    : in Positive;{"\n"}                   Going   : in Direction := Forward;{"\n"}                   Mapping : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source   : in String;{"\n"}                   Pattern  : in String;{"\n"}                   Going    : in Direction := Forward;{"\n"}                   Mapping  : in Maps.Character_Mapping{"\n"}                                := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source   : in String;{"\n"}                   Pattern  : in String;{"\n"}                   Going    : in Direction := Forward;{"\n"}                   Mapping  : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in String;{"\n"}                   Set     : in Maps.Character_Set;{"\n"}                   From    : in Positive;{"\n"}                   Test    : in Membership := Inside;{"\n"}                   Going   : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source : in String;{"\n"}                   Set    : in Maps.Character_Set;{"\n"}                   Test   : in Membership := Inside;{"\n"}                   Going  : in Direction  := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index_Non_Blank (Source : in String;{"\n"}                             From   : in Positive;{"\n"}                             Going  : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index_Non_Blank (Source : in String;{"\n"}                             Going  : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in String;{"\n"}                   Pattern  : in String;{"\n"}                   Mapping  : in Maps.Character_Mapping{"\n"}                                 := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in String;{"\n"}                   Pattern  : in String;{"\n"}                   Mapping  : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in String;{"\n"}                   Set      : in Maps.Character_Set){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0031-1"}{"}"}    procedure Find_Token (Source : in String;{"\n"}                         Set    : in Maps.Character_Set;{"\n"}                         From   : in Positive;{"\n"}                         Test   : in Membership;{"\n"}                         First  : out Positive;{"\n"}                         Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Find_Token (Source : in String;{"\n"}                         Set    : in Maps.Character_Set;{"\n"}                         Test   : in Membership;{"\n"}                         First  : out Positive;{"\n"}                         Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
-- String translation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
   function Translate (Source  : in String;{"\n"}                       Mapping : in Maps.Character_Mapping){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Translate (Source  : in out String;{"\n"}                        Mapping : in Maps.Character_Mapping);{"\n"}
</CodeBlock>

<CodeBlock>
   function Translate (Source  : in String;{"\n"}                       Mapping : in Maps.Character_Mapping_Function){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Translate (Source  : in out String;{"\n"}                        Mapping : in Maps.Character_Mapping_Function);{"\n"}
</CodeBlock>

<CodeBlock>
-- String transformation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
   function Replace_Slice (Source   : in String;{"\n"}                           Low      : in Positive;{"\n"}                           High     : in Natural;{"\n"}                           By       : in String){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Replace_Slice (Source   : in out String;{"\n"}                            Low      : in Positive;{"\n"}                            High     : in Natural;{"\n"}                            By       : in String;{"\n"}                            Drop     : in Truncation := Error;{"\n"}                            Justify  : in Alignment  := Left;{"\n"}                            Pad      : in Character  := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function Insert (Source   : in String;{"\n"}                    Before   : in Positive;{"\n"}                    New_Item : in String){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Insert (Source   : in out String;{"\n"}                     Before   : in Positive;{"\n"}                     New_Item : in String;{"\n"}                     Drop     : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
   function Overwrite (Source   : in String;{"\n"}                       Position : in Positive;{"\n"}                       New_Item : in String){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Overwrite (Source   : in out String;{"\n"}                        Position : in Positive;{"\n"}                        New_Item : in String;{"\n"}                        Drop     : in Truncation := Right);{"\n"}
</CodeBlock>

<CodeBlock>
   function Delete (Source  : in String;{"\n"}                    From    : in Positive;{"\n"}                    Through : in Natural){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Delete (Source  : in out String;{"\n"}                     From    : in Positive;{"\n"}                     Through : in Natural;{"\n"}                     Justify : in Alignment := Left;{"\n"}                     Pad     : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
 --String selector subprograms{"\n"}   function Trim (Source : in String;{"\n"}                  Side   : in Trim_End){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Trim (Source  : in out String;{"\n"}                   Side    : in Trim_End;{"\n"}                   Justify : in Alignment := Left;{"\n"}                   Pad     : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function Trim (Source : in String;{"\n"}                  Left   : in Maps.Character_Set;{"\n"}                  Right  : in Maps.Character_Set){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Trim (Source  : in out String;{"\n"}                   Left    : in Maps.Character_Set;{"\n"}                   Right   : in Maps.Character_Set;{"\n"}                   Justify : in Alignment := Strings.Left;{"\n"}                   Pad     : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function Head (Source : in String;{"\n"}                  Count  : in Natural;{"\n"}                  Pad    : in Character := Space){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Head (Source  : in out String;{"\n"}                   Count   : in Natural;{"\n"}                   Justify : in Alignment := Left;{"\n"}                   Pad     : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function Tail (Source : in String;{"\n"}                  Count  : in Natural;{"\n"}                  Pad    : in Character := Space){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Tail (Source  : in out String;{"\n"}                   Count   : in Natural;{"\n"}                   Justify : in Alignment := Left;{"\n"}                   Pad     : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
--String constructor functions{"\n"}
</CodeBlock>

<CodeBlock>
   function "*" (Left  : in Natural;{"\n"}                 Right : in Character) return String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "*" (Left  : in Natural;{"\n"}                 Right : in String) return String;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.Fixed;{"\n"}
</CodeBlock>

<p>The effects of the above subprograms are as follows. </p>
<CodeBlock>
procedure Move (Source  : in  String;{"\n"}                Target  : out String;{"\n"}                Drop    : in  Truncation := Error;{"\n"}                Justify : in  Alignment  := Left;{"\n"}                Pad     : in  Character  := Space);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} The Move procedure copies characters from Source to Target. If Source has the same length as Target, then the effect is to assign Source to Target. If Source is shorter than Target, then: </p>
<p>If Justify=Left, then Source is copied into the first Source'Length characters of Target.</p>
<p>If Justify=Right, then Source is copied into the last Source'Length characters of Target.</p>
<p>If Justify=Center, then Source is copied into the middle Source'Length characters of Target. In this case, if the difference in length between Target and Source is odd, then the extra Pad character is on the right.</p>
<p>Pad is copied to each Target character not otherwise assigned. </p>
<p>If Source is longer than Target, then the effect is based on Drop. </p>
<p>If Drop=Left, then the rightmost Target'Length characters of Source are copied into Target.</p>
<p>If Drop=Right, then the leftmost Target'Length characters of Source are copied into Target.</p>
<p>If Drop=Error, then the effect depends on the value of the Justify parameter and also on whether any characters in Source other than Pad would fail to be copied: </p>
<p>If Justify=Left, and if each of the rightmost Source'Length-Target'Length characters in Source is Pad, then the leftmost Target'Length characters of Source are copied to Target.</p>
<p>If Justify=Right, and if each of the leftmost Source'Length-Target'Length characters in Source is Pad, then the rightmost Target'Length characters of Source are copied to Target.</p>
<p>Otherwise, Length_Error is propagated. </p>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>The Move procedure will work even if Source and Target overlap.</p></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>The order of parameters (Source before Target) corresponds to the order in COBOL's MOVE verb.</p></Admonition>

<CodeBlock>
function Index (Source  : in String;{"\n"}                Pattern : in String;{"\n"}                From    : in Positive;{"\n"}                Going   : in Direction := Forward;{"\n"}                Mapping : in Maps.Character_Mapping := Maps.Identity){"\n"}   return Natural;{"\n"}{"\n"}function Index (Source  : in String;{"\n"}                Pattern : in String;{"\n"}                From    : in Positive;{"\n"}                Going   : in Direction := Forward;{"\n"}                Mapping : in Maps.Character_Mapping_Function){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0056-1"}</em>{"}"} Each Index function searches, starting from From, for a slice of Source, with length Pattern'Length, that matches Pattern with respect to Mapping; the parameter Going indicates the direction of the lookup. If Source is the null string, Index returns 0; otherwise, if From is not in Source'Range, then Index_Error is propagated. If Going = Forward, then Index returns the smallest index I which is greater than or equal to From such that the slice of Source starting at I matches Pattern. If Going = Backward, then Index returns the largest index I such that the slice of Source starting at I matches Pattern and has an upper bound less than or equal to From. If there is no such slice, then 0 is returned. If Pattern is the null string, then Pattern_Error is propagated.</p>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<p><strong></strong>There is no default parameter for From; the default value would need to depend on other parameters (the bounds of Source and the direction Going). It is better to use overloaded functions rather than a special value to represent the default.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>There is no default value for the Mapping parameter that is a Character_Mapping_Function; if there were, a call would be ambiguous since there is also a default for the Mapping parameter that is a Character_Mapping.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0056-1"}</em>{"}"} The language does not define when the Pattern_Error check is made. (That's because many common searching implementations require a nonempty pattern) That means that the result for a call like Index ("", "") could be 0 or could raise Pattern_Error. Similarly, in the call Index ("", "", From ={">"} 2), the language does not define whether Pattern_Error or Index_Error is raised.</p></Admonition>

<CodeBlock>
function Index (Source   : in String;{"\n"}                Pattern  : in String;{"\n"}                Going    : in Direction := Forward;{"\n"}                Mapping  : in Maps.Character_Mapping{"\n"}                              := Maps.Identity){"\n"}   return Natural;{"\n"}{"\n"}function Index (Source   : in String;{"\n"}                Pattern  : in String;{"\n"}                Going    : in Direction := Forward;{"\n"}                Mapping  : in Maps.Character_Mapping_Function){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} If Going = Forward, returns </p>
<CodeBlock>
      Index (Source, Pattern, Source'First, Forward, Mapping);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} otherwise, returns </p>
<CodeBlock>
      Index (Source, Pattern, Source'Last, Backward, Mapping);{"\n"}
</CodeBlock>

<Admonition type="aarm" aarm="note" title="Note: ">
<p><em>This paragraph was deleted.</em>There is no default value for the Mapping parameter that is a Character_Mapping_Function; if there were, a call would be ambiguous since there is also a default for the Mapping parameter that is a Character_Mapping. </p></Admonition>

<CodeBlock>
function Index (Source  : in String;{"\n"}                Set     : in Maps.Character_Set;{"\n"}                From    : in Positive;{"\n"}                Test    : in Membership := Inside;{"\n"}                Going   : in Direction := Forward){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0056-1"}</em>{"}"} Index searches for the first or last occurrence of any of a set of characters (when Test=Inside), or any of the complement of a set of characters (when Test=Outside). If Source is the null string, Index returns 0; otherwise, if From is not in Source'Range, then Index_Error is propagated. Otherwise, it returns the smallest index I {">"}= From (if Going=Forward) or the largest index I {"<"}= From (if Going=Backward) such that Source(I) satisfies the Test condition with respect to Set; it returns 0 if there is no such Character in Source.</p>
<CodeBlock>
function Index (Source : in String;{"\n"}                Set    : in Maps.Character_Set;{"\n"}                Test   : in Membership := Inside;{"\n"}                Going  : in Direction  := Forward){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} If Going = Forward, returns </p>
<CodeBlock>
      Index (Source, Set, Source'First, Test, Forward);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} otherwise, returns </p>
<CodeBlock>
      Index (Source, Set, Source'Last, Test, Backward);{"\n"}
</CodeBlock>

<CodeBlock>
function Index_Non_Blank (Source : in String;{"\n"}                          From   : in Positive;{"\n"}                          Going  : in Direction := Forward){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Returns Index (Source, Maps.To_Set(Space), From, Outside, Going);</p>
<CodeBlock>
function Index_Non_Blank (Source : in String;{"\n"}                          Going  : in Direction := Forward){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>Returns Index(Source, Maps.To_Set(Space), Outside, Going)</p>
<CodeBlock>
function Count (Source   : in String;{"\n"}                Pattern  : in String;{"\n"}                Mapping  : in Maps.Character_Mapping{"\n"}                             := Maps.Identity){"\n"}   return Natural;{"\n"}{"\n"}function Count (Source   : in String;{"\n"}                Pattern  : in String;{"\n"}                Mapping  : in Maps.Character_Mapping_Function){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>Returns the maximum number of nonoverlapping slices of Source that match Pattern with respect to Mapping. If Pattern is the null string then Pattern_Error is propagated. </p>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>We say `maximum number' because it is possible to slice a source string in different ways yielding different numbers of matches. For example if Source is "ABABABA" and Pattern is "ABA", then Count yields 2, although there is a partitioning of Source that yields just 1 match, for the middle slice. Saying `maximum number' is equivalent to saying that the pattern match starts either at the low index or the high index position. </p></Admonition>

<CodeBlock>
function Count (Source   : in String;{"\n"}                Set      : in Maps.Character_Set){"\n"}   return Natural;{"\n"}
</CodeBlock>

<p>Returns the number of occurrences in Source of characters that are in Set.</p>
<CodeBlock>
procedure Find_Token (Source : in String;{"\n"}                      Set    : in Maps.Character_Set;{"\n"}                      From   : in Positive;{"\n"}                      Test   : in Membership;{"\n"}                      First  : out Positive;{"\n"}                      Last   : out Natural);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0031-1"}</em>{"}"} If Source is not the null string and From is not in Source'Range, then Index_Error is raised. Otherwise, First is set to the index of the first character in Source(From .. Source'Last) that satisfies the Test condition. Last is set to the largest index such that all characters in Source(First .. Last) satisfy the Test condition. If no characters in Source(From .. Source'Last) satisfy the Test condition, First is set to From, and Last is set to 0.</p>
<CodeBlock>
procedure Find_Token (Source : in String;{"\n"}                      Set    : in Maps.Character_Set;{"\n"}                      Test   : in Membership;{"\n"}                      First  : out Positive;{"\n"}                      Last   : out Natural);{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} {"{"}<em>{"AI05-0031-1"}</em>{"}"} Equivalent to Find_Token (Source, Set, Source'First, Test, First, Last).</p>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>{"{"}<em>{"AI05-0031-1"}</em>{"}"} If Source'First is not in Positive, which can only happen for an empty string, this will raise Constraint_Error. </p></Admonition>

<CodeBlock>
function Translate (Source  : in String;{"\n"}                    Mapping : in Maps.Character_Mapping){"\n"}   return String;{"\n"}{"\n"}function Translate (Source  : in String;{"\n"}                    Mapping : in Maps.Character_Mapping_Function){"\n"}   return String;{"\n"}
</CodeBlock>

<p>Returns the string S whose length is Source'Length and such that S(I) is the character to which Mapping maps the corresponding element of Source, for I in 1..Source'Length.</p>
<CodeBlock>
procedure Translate (Source  : in out String;{"\n"}                     Mapping : in Maps.Character_Mapping);{"\n"}{"\n"}procedure Translate (Source  : in out String;{"\n"}                     Mapping : in Maps.Character_Mapping_Function);{"\n"}
</CodeBlock>

<p>Equivalent to Source := Translate(Source, Mapping).</p>
<CodeBlock>
function Replace_Slice (Source   : in String;{"\n"}                        Low      : in Positive;{"\n"}                        High     : in Natural;{"\n"}                        By       : in String){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} If Low {">"} Source'Last+1, or High {"<"} Source'First1, then Index_Error is propagated. Otherwise:</p>
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} If High {">"}= Low, then the returned string comprises Source(Source'First..Low1) & By & Source(High+1..Source'Last), but with lower bound 1.</p>
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} If High {"<"} Low, then the returned string is Insert(Source, Before={">"}Low, New_Item={">"}By). </p>
<CodeBlock>
procedure Replace_Slice (Source   : in out String;{"\n"}                         Low      : in Positive;{"\n"}                         High     : in Natural;{"\n"}                         By       : in String;{"\n"}                         Drop     : in Truncation := Error;{"\n"}                         Justify  : in Alignment  := Left;{"\n"}                         Pad      : in Character  := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Replace_Slice(Source, Low, High, By), Source, Drop, Justify, Pad).</p>
<CodeBlock>
function Insert (Source   : in String;{"\n"}                 Before   : in Positive;{"\n"}                 New_Item : in String){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} Propagates Index_Error if Before is not in Source'First .. Source'Last+1; otherwise, returns Source(Source'First..Before1) & New_Item & Source(Before..Source'Last), but with lower bound 1.</p>
<CodeBlock>
procedure Insert (Source   : in out String;{"\n"}                  Before   : in Positive;{"\n"}                  New_Item : in String;{"\n"}                  Drop     : in Truncation := Error);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Insert(Source, Before, New_Item), Source, Drop).</p>
<CodeBlock>
function Overwrite (Source   : in String;{"\n"}                    Position : in Positive;{"\n"}                    New_Item : in String){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} Propagates Index_Error if Position is not in Source'First .. Source'Last+1; otherwise, returns the string obtained from Source by consecutively replacing characters starting at Position with corresponding characters from New_Item. If the end of Source is reached before the characters in New_Item are exhausted, the remaining characters from New_Item are appended to the string.</p>
<CodeBlock>
procedure Overwrite (Source   : in out String;{"\n"}                     Position : in Positive;{"\n"}                     New_Item : in String;{"\n"}                     Drop     : in Truncation := Right);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Overwrite(Source, Position, New_Item), Source, Drop).</p>
<CodeBlock>
function Delete (Source  : in String;{"\n"}                 From    : in Positive;{"\n"}                 Through : in Natural){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} {"{"}<em>{"AI05-0264-1"}</em>{"}"} If From {"<"}= Through, the returned string is Replace_Slice(Source, From, Through, ""); otherwise, it is Source with lower bound 1.</p>
<CodeBlock>
procedure Delete (Source  : in out String;{"\n"}                  From    : in Positive;{"\n"}                  Through : in Natural;{"\n"}                  Justify : in Alignment := Left;{"\n"}                  Pad     : in Character := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Delete(Source, From, Through), Source, Justify ={">"} Justify, Pad ={">"} Pad).</p>
<CodeBlock>
function Trim (Source : in String;{"\n"}               Side   : in Trim_End){"\n"}  return String;{"\n"}
</CodeBlock>

<p>Returns the string obtained by removing from Source all leading Space characters (if Side = Left), all trailing Space characters (if Side = Right), or all leading and trailing Space characters (if Side = Both).</p>
<CodeBlock>
procedure Trim (Source  : in out String;{"\n"}                Side    : in Trim_End;{"\n"}                Justify : in Alignment := Left;{"\n"}                Pad     : in Character := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Trim(Source, Side), Source, Justify={">"}Justify, Pad={">"}Pad).</p>
<CodeBlock>
function Trim (Source : in String;{"\n"}               Left   : in Maps.Character_Set;{"\n"}               Right  : in Maps.Character_Set){"\n"}   return String;{"\n"}
</CodeBlock>

<p>Returns the string obtained by removing from Source all leading characters in Left and all trailing characters in Right.</p>
<CodeBlock>
procedure Trim (Source  : in out String;{"\n"}                Left    : in Maps.Character_Set;{"\n"}                Right   : in Maps.Character_Set;{"\n"}                Justify : in Alignment := Strings.Left;{"\n"}                Pad     : in Character := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Trim(Source, Left, Right), Source, Justify ={">"} Justify, Pad={">"}Pad).</p>
<CodeBlock>
function Head (Source : in String;{"\n"}               Count  : in Natural;{"\n"}               Pad    : in Character := Space){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} Returns a string of length Count. If Count {"<"}= Source'Length, the string comprises the first Count characters of Source. Otherwise, its contents are Source concatenated with CountSource'Length Pad characters.</p>
<CodeBlock>
procedure Head (Source  : in out String;{"\n"}                Count   : in Natural;{"\n"}                Justify : in Alignment := Left;{"\n"}                Pad     : in Character := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Head(Source, Count, Pad), Source, Drop={">"}Error, Justify={">"}Justify, Pad={">"}Pad).</p>
<CodeBlock>
function Tail (Source : in String;{"\n"}               Count  : in Natural;{"\n"}               Pad    : in Character := Space){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} Returns a string of length Count. If Count {"<"}= Source'Length, the string comprises the last Count characters of Source. Otherwise, its contents are Count-Source'Length Pad characters concatenated with Source.</p>
<CodeBlock>
procedure Tail (Source  : in out String;{"\n"}                Count   : in Natural;{"\n"}                Justify : in Alignment := Left;{"\n"}                Pad     : in Character := Space);{"\n"}
</CodeBlock>

<p>Equivalent to Move(Tail(Source, Count, Pad), Source, Drop={">"}Error, Justify={">"}Justify, Pad={">"}Pad).</p>
<CodeBlock>
function "*" (Left  : in Natural;{"\n"}              Right : in Character) return String;{"\n"}{"\n"}function "*" (Left  : in Natural;{"\n"}              Right : in String) return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} These functions replicate a character or string a specified number of times. The first function returns a string whose length is Left and each of whose elements is Right. The second function returns a string whose length is Left*Right'Length and whose value is the null string if Left = 0 and otherwise is (Left1)*Right & Right with lower bound 1. </p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 1   {"{"}<em>{"AI05-0264-1"}</em>{"}"} {"{"}<em>{"AI12-0442-1"}</em>{"}"} In the Index and Count functions taking Pattern and Mapping parameters, for there to be a match, the actual String parameter passed to Pattern can contain only characters occurring as target characters of the mapping.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 2   In the Insert subprograms, inserting at the end of a string is obtained by passing Source'Last+1 as the Before parameter.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 3   If a null Character_Mapping_Function is passed to any of the string handling subprograms, Constraint_Error is propagated. </p></Admonition>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0005-1"}</em>{"}"} Overloaded versions of Index and Index_Non_Blank are added to Strings.Fixed. If Strings.Fixed is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> of Index or Index_Non_Blank is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} <strong>Corrigendum:</strong> Clarified that Find_Token may raise Constraint_Error if Source'First is not in Positive (which is only possible for a null string).</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} <strong>Corrigendum:</strong> Clarified that Replace_Slice, Delete, and "*" always return a string with lower bound 1. </p></Admonition>


#### Incompatibilities With Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0031-1"}</em>{"}"} An overloaded version of Find_Token is added to Strings.Fixed. If Strings.Fixed is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> of Find_Token is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI05-0056-1"}</em>{"}"} <strong></strong> Clarified that Index never raises Index_Error if the source string is null. </p></Admonition>


## A.4.4  Bounded-Length String Handling

<p>{"{"}<em>{"AI12-0445-1"}</em>{"}"} The language-defined package Strings.Bounded provides a generic package each of whose instances yields a private type Bounded_String and a set of operations. An object of a particular Bounded_String type represents a String whose low bound is 1 and whose length can vary conceptually between 0 and a maximum size established at the generic instantiation. The subprograms for fixed-length string handling are either overloaded directly for Bounded_String, or are modified as necessary to reflect the variability in length. Additionally, since the Bounded_String type is private, appropriate constructor and selector operations are provided. </p>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>Strings.Bounded declares an inner generic package, versus itself being directly a generic child of Strings, in order to retain compatibility with a version of the string-handling packages that is generic with respect to the character and string types.</p></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>The bound of a bounded-length string is specified as a parameter to a generic, versus as the value for a discriminant, because of the inappropriateness of assignment and equality of discriminated types for the copying and comparison of bounded strings.</p></Admonition>


#### Static Semantics

<p>The library package Strings.Bounded has the following declaration: </p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Strings.Maps;{"\n"}package Ada.Strings.Bounded{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
</CodeBlock>

<CodeBlock>
   generic{"\n"}      Max   : Positive;    -- Maximum length of a Bounded_String{"\n"}   package Generic_Bounded_Length is{"\n"}
</CodeBlock>

<CodeBlock>
      Max_Length : constant Positive := Max;{"\n"}
</CodeBlock>

<CodeBlock>
      type Bounded_String is private;{"\n"}
</CodeBlock>

<CodeBlock>
      Null_Bounded_String : constant Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      subtype Length_Range is Natural range 0 .. Max_Length;{"\n"}
</CodeBlock>

<CodeBlock>
      function Length (Source : in Bounded_String) return Length_Range;{"\n"}
</CodeBlock>

<CodeBlock>
   -- Conversion, Concatenation, and Selection functions{"\n"}
</CodeBlock>

<CodeBlock>
      function To_Bounded_String (Source : in String;{"\n"}                                  Drop   : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function To_String (Source : in Bounded_String) return String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       procedure Set_Bounded_String{"\n"}         (Target :    out Bounded_String;{"\n"}          Source : in     String;{"\n"}          Drop   : in     Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function Append (Left, Right : in Bounded_String;{"\n"}                       Drop        : in Truncation  := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Append (Left  : in Bounded_String;{"\n"}                       Right : in String;{"\n"}                       Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Append (Left  : in String;{"\n"}                       Right : in Bounded_String;{"\n"}                       Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Append (Left  : in Bounded_String;{"\n"}                       Right : in Character;{"\n"}                       Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Append (Left  : in Character;{"\n"}                       Right : in Bounded_String;{"\n"}                       Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Append (Source   : in out Bounded_String;{"\n"}                        New_Item : in Bounded_String;{"\n"}                        Drop     : in Truncation  := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Append (Source   : in out Bounded_String;{"\n"}                        New_Item : in String;{"\n"}                        Drop     : in Truncation  := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Append (Source   : in out Bounded_String;{"\n"}                        New_Item : in Character;{"\n"}                        Drop     : in Truncation  := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function "&" (Left, Right : in Bounded_String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "&" (Left : in Bounded_String; Right : in String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "&" (Left : in String; Right : in Bounded_String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "&" (Left : in Bounded_String; Right : in Character){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "&" (Left : in Character; Right : in Bounded_String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Element (Source : in Bounded_String;{"\n"}                        Index  : in Positive){"\n"}         return Character;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Replace_Element (Source : in out Bounded_String;{"\n"}                                 Index  : in Positive;{"\n"}                                 By     : in Character);{"\n"}
</CodeBlock>

<CodeBlock>
      function Slice (Source : in Bounded_String;{"\n"}                      Low    : in Positive;{"\n"}                      High   : in Natural){"\n"}         return String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       function Bounded_Slice{"\n"}         (Source : in Bounded_String;{"\n"}          Low    : in Positive;{"\n"}          High   : in Natural){"\n"}             return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       procedure Bounded_Slice{"\n"}         (Source : in     Bounded_String;{"\n"}          Target :    out Bounded_String;{"\n"}          Low    : in     Positive;{"\n"}          High   : in     Natural);{"\n"}
</CodeBlock>

<CodeBlock>
      function "="  (Left, Right : in Bounded_String) return Boolean;{"\n"}      function "="  (Left : in Bounded_String; Right : in String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "="  (Left : in String; Right : in Bounded_String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}"  (Left, Right : in Bounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}"  (Left : in Bounded_String; Right : in String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}"  (Left : in String; Right : in Bounded_String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}=" (Left, Right : in Bounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}="  (Left : in Bounded_String; Right : in String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{"<"}="  (Left : in String; Right : in Bounded_String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}"  (Left, Right : in Bounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}"  (Left : in Bounded_String; Right : in String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}"  (Left : in String; Right : in Bounded_String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}=" (Left, Right : in Bounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}="  (Left : in Bounded_String; Right : in String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
      function "{">"}="  (Left : in String; Right : in Bounded_String){"\n"}        return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    -- Search subprograms{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       function Index (Source  : in Bounded_String;{"\n"}                      Pattern : in String;{"\n"}                      From    : in Positive;{"\n"}                      Going   : in Direction := Forward;{"\n"}                      Mapping : in Maps.Character_Mapping := Maps.Identity){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       function Index (Source  : in Bounded_String;{"\n"}                      Pattern : in String;{"\n"}                      From    : in Positive;{"\n"}                      Going   : in Direction := Forward;{"\n"}                      Mapping : in Maps.Character_Mapping_Function){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Index (Source   : in Bounded_String;{"\n"}                      Pattern  : in String;{"\n"}                      Going    : in Direction := Forward;{"\n"}                      Mapping  : in Maps.Character_Mapping{"\n"}                                 := Maps.Identity){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Index (Source   : in Bounded_String;{"\n"}                      Pattern  : in String;{"\n"}                      Going    : in Direction := Forward;{"\n"}                      Mapping  : in Maps.Character_Mapping_Function){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       function Index (Source  : in Bounded_String;{"\n"}                      Set     : in Maps.Character_Set;{"\n"}                      From    : in Positive;{"\n"}                      Test    : in Membership := Inside;{"\n"}                      Going   : in Direction := Forward){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Index (Source : in Bounded_String;{"\n"}                      Set    : in Maps.Character_Set;{"\n"}                      Test   : in Membership := Inside;{"\n"}                      Going  : in Direction  := Forward){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}       function Index_Non_Blank (Source : in Bounded_String;{"\n"}                                From   : in Positive;{"\n"}                                Going  : in Direction := Forward){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Index_Non_Blank (Source : in Bounded_String;{"\n"}                                Going  : in Direction := Forward){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Count (Source   : in Bounded_String;{"\n"}                      Pattern  : in String;{"\n"}                      Mapping  : in Maps.Character_Mapping{"\n"}                                   := Maps.Identity){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Count (Source   : in Bounded_String;{"\n"}                      Pattern  : in String;{"\n"}                      Mapping  : in Maps.Character_Mapping_Function){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
      function Count (Source   : in Bounded_String;{"\n"}                      Set      : in Maps.Character_Set){"\n"}         return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0031-1"}{"}"}       procedure Find_Token (Source : in Bounded_String;{"\n"}                            Set    : in Maps.Character_Set;{"\n"}                            From   : in Positive;{"\n"}                            Test   : in Membership;{"\n"}                            First  : out Positive;{"\n"}                            Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Find_Token (Source : in Bounded_String;{"\n"}                            Set    : in Maps.Character_Set;{"\n"}                            Test   : in Membership;{"\n"}                            First  : out Positive;{"\n"}                            Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   -- String translation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
      function Translate (Source  : in Bounded_String;{"\n"}                          Mapping : in Maps.Character_Mapping){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Translate (Source  : in out Bounded_String;{"\n"}                           Mapping : in Maps.Character_Mapping);{"\n"}
</CodeBlock>

<CodeBlock>
      function Translate (Source  : in Bounded_String;{"\n"}                          Mapping : in Maps.Character_Mapping_Function){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Translate (Source  : in out Bounded_String;{"\n"}                           Mapping : in Maps.Character_Mapping_Function);{"\n"}
</CodeBlock>

<CodeBlock>
   -- String transformation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
      function Replace_Slice (Source   : in Bounded_String;{"\n"}                              Low      : in Positive;{"\n"}                              High     : in Natural;{"\n"}                              By       : in String;{"\n"}                              Drop     : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Replace_Slice (Source   : in out Bounded_String;{"\n"}                               Low      : in Positive;{"\n"}                               High     : in Natural;{"\n"}                               By       : in String;{"\n"}                               Drop     : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function Insert (Source   : in Bounded_String;{"\n"}                       Before   : in Positive;{"\n"}                       New_Item : in String;{"\n"}                       Drop     : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Insert (Source   : in out Bounded_String;{"\n"}                        Before   : in Positive;{"\n"}                        New_Item : in String;{"\n"}                        Drop     : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function Overwrite (Source    : in Bounded_String;{"\n"}                          Position  : in Positive;{"\n"}                          New_Item  : in String;{"\n"}                          Drop      : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Overwrite (Source    : in out Bounded_String;{"\n"}                           Position  : in Positive;{"\n"}                           New_Item  : in String;{"\n"}                           Drop      : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function Delete (Source  : in Bounded_String;{"\n"}                       From    : in Positive;{"\n"}                       Through : in Natural){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Delete (Source  : in out Bounded_String;{"\n"}                        From    : in Positive;{"\n"}                        Through : in Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   --String selector subprograms{"\n"}
</CodeBlock>

<CodeBlock>
      function Trim (Source : in Bounded_String;{"\n"}                     Side   : in Trim_End){"\n"}         return Bounded_String;{"\n"}      procedure Trim (Source : in out Bounded_String;{"\n"}                      Side   : in Trim_End);{"\n"}
</CodeBlock>

<CodeBlock>
      function Trim (Source : in Bounded_String;{"\n"}                     Left   : in Maps.Character_Set;{"\n"}                     Right  : in Maps.Character_Set){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Trim (Source : in out Bounded_String;{"\n"}                      Left   : in Maps.Character_Set;{"\n"}                      Right  : in Maps.Character_Set);{"\n"}
</CodeBlock>

<CodeBlock>
      function Head (Source : in Bounded_String;{"\n"}                     Count  : in Natural;{"\n"}                     Pad    : in Character  := Space;{"\n"}                     Drop   : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Head (Source : in out Bounded_String;{"\n"}                      Count  : in Natural;{"\n"}                      Pad    : in Character  := Space;{"\n"}                      Drop   : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
      function Tail (Source : in Bounded_String;{"\n"}                     Count  : in Natural;{"\n"}                     Pad    : in Character  := Space;{"\n"}                     Drop   : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      procedure Tail (Source : in out Bounded_String;{"\n"}                      Count  : in Natural;{"\n"}                      Pad    : in Character  := Space;{"\n"}                      Drop   : in Truncation := Error);{"\n"}
</CodeBlock>

<CodeBlock>
   --String constructor subprograms{"\n"}
</CodeBlock>

<CodeBlock>
      function "*" (Left  : in Natural;{"\n"}                    Right : in Character){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "*" (Left  : in Natural;{"\n"}                    Right : in String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function "*" (Left  : in Natural;{"\n"}                    Right : in Bounded_String){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Replicate (Count : in Natural;{"\n"}                          Item  : in Character;{"\n"}                          Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Replicate (Count : in Natural;{"\n"}                          Item  : in String;{"\n"}                          Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
      function Replicate (Count : in Natural;{"\n"}                          Item  : in Bounded_String;{"\n"}                          Drop  : in Truncation := Error){"\n"}         return Bounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   private{"\n"}       ... -- not specified by the language{"\n"}   end Generic_Bounded_Length;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.Bounded;{"\n"}
</CodeBlock>

<Admonition type="aarm" aarm="note" title="Note: ">
<p><em>This paragraph was deleted.</em>{"{"}<em>8652/0097</em>{"}"} {"{"}<em>{"AI95-00115-01"}</em>{"}"} {"{"}<em>{"AI95-00344-01"}</em>{"}"} </p></Admonition>

<p>Null_Bounded_String represents the null string. If an object of type Bounded_String is not otherwise initialized, it will be initialized to the same value as Null_Bounded_String. </p>
<CodeBlock>
function Length (Source : in Bounded_String) return Length_Range;{"\n"}
</CodeBlock>

<p>The Length function returns the length of the string represented by Source.</p>
<CodeBlock>
function To_Bounded_String (Source : in String;{"\n"}                            Drop   : in Truncation := Error){"\n"}   return Bounded_String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0264-1"}</em>{"}"} If Source'Length {"<"}= Max_Length, then this function returns a Bounded_String that represents Source. Otherwise, the effect depends on the value of Drop: </p>
<p>If Drop=Left, then the result is a Bounded_String that represents the string comprising the rightmost Max_Length characters of Source.</p>
<p>If Drop=Right, then the result is a Bounded_String that represents the string comprising the leftmost Max_Length characters of Source.</p>
<p>If Drop=Error, then Strings.Length_Error is propagated. </p>
<CodeBlock>
function To_String (Source : in Bounded_String) return String;{"\n"}
</CodeBlock>

<p>To_String returns the String value with lower bound 1 represented by Source. If B is a Bounded_String, then B = To_Bounded_String(To_String(B)).</p>
<CodeBlock>
procedure Set_Bounded_String{"\n"}   (Target :    out Bounded_String;{"\n"}    Source : in     String;{"\n"}    Drop   : in     Truncation := Error);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Equivalent to Target := To_Bounded_String (Source, Drop);</p>
<p>Each of the Append functions returns a Bounded_String obtained by concatenating the string or character given or represented by one of the parameters, with the string or character given or represented by the other parameter, and applying To_Bounded_String to the concatenation result string, with Drop as provided to the Append function.</p>
<p>Each of the procedures Append(Source, New_Item, Drop) has the same effect as the corresponding assignment Source := Append(Source, New_Item, Drop).</p>
<p>Each of the "&" functions has the same effect as the corresponding Append function, with Error as the Drop parameter. </p>
<CodeBlock>
function Element (Source : in Bounded_String;{"\n"}                  Index  : in Positive){"\n"}   return Character;{"\n"}
</CodeBlock>

<p>Returns the character at position Index in the string represented by Source; propagates Index_Error if Index {">"} Length(Source).</p>
<CodeBlock>
procedure Replace_Element (Source : in out Bounded_String;{"\n"}                           Index  : in Positive;{"\n"}                           By     : in Character);{"\n"}
</CodeBlock>

<p>Updates Source such that the character at position Index in the string represented by Source is By; propagates Index_Error if Index {">"} Length(Source).</p>
<CodeBlock>
function Slice (Source : in Bounded_String;{"\n"}                Low    : in Positive;{"\n"}                High   : in Natural){"\n"}   return String;{"\n"}
</CodeBlock>

<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} {"{"}<em>{"AI95-00238-01"}</em>{"}"} Returns the slice at positions Low through High in the string represented by Source; propagates Index_Error if Low {">"} Length(Source)+1 or High {">"} Length(Source). The bounds of the returned string are Low and High.</p>
<CodeBlock>
function Bounded_Slice{"\n"}   (Source : in Bounded_String;{"\n"}    Low    : in Positive;{"\n"}    High   : in Natural){"\n"}       return Bounded_String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Returns the slice at positions Low through High in the string represented by Source as a bounded string; propagates Index_Error if Low {">"} Length(Source)+1 or High {">"} Length(Source).</p>
<CodeBlock>
procedure Bounded_Slice{"\n"}   (Source : in     Bounded_String;{"\n"}    Target :    out Bounded_String;{"\n"}    Low    : in     Positive;{"\n"}    High   : in     Natural);{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Equivalent to Target := Bounded_Slice (Source, Low, High);</p>
<p>Each of the functions "=", "{"<"}", "{">"}", "{"<"}=", and "{">"}=" returns the same result as the corresponding String operation applied to the String values given or represented by the two parameters.</p>
<p>Each of the search subprograms (Index, Index_Non_Blank, Count, Find_Token) has the same effect as the corresponding subprogram in Strings.Fixed applied to the string represented by the Bounded_String parameter.</p>
<p>Each of the Translate subprograms, when applied to a Bounded_String, has an analogous effect to the corresponding subprogram in Strings.Fixed. For the Translate function, the translation is applied to the string represented by the Bounded_String parameter, and the result is converted (via To_Bounded_String) to a Bounded_String. For the Translate procedure, the string represented by the Bounded_String parameter after the translation is given by the Translate function for fixed-length strings applied to the string represented by the original value of the parameter.</p>
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} Each of the transformation subprograms (Replace_Slice, Insert, Overwrite, Delete), selector subprograms (Trim, Head, Tail), and constructor functions ("*") has an effect based on its corresponding subprogram in Strings.Fixed, and Replicate is based on Fixed."*". In the case of a function, the corresponding fixed-length string subprogram is applied to the string represented by the Bounded_String parameter. To_Bounded_String is applied the result string, with Drop (or Error in the case of Generic_Bounded_Length."*") determining the effect when the string length exceeds Max_Length. In the case of a procedure, the corresponding function in Strings.Bounded.Generic_Bounded_Length is applied, with the result assigned into the Source parameter. </p>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>{"{"}<em>{"AI95-00114-01"}</em>{"}"} The "/=" operations between Bounded_String and String, and between String and Bounded_String, are automatically defined based on the corresponding "=" operations. </p></Admonition>


#### Implementation Advice

<p>Bounded string objects should not be implemented by implicit pointers and dynamic allocation. </p>
<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<p><strong></strong>Bounded string objects should not be implemented by implicit pointers and dynamic allocation.</p></Admonition>

<Admonition type="aarm" aarm="implementation-note" title="Implementation Note: ">
<p><strong></strong>The following is a possible implementation of the private part of the package: </p></Admonition>

<CodeBlock>
type Bounded_String_Internals (Length : Length_Range := 0) is{"\n"}   record{"\n"}      Data : String(1..Length);{"\n"}   end record;{"\n"}
</CodeBlock>

<CodeBlock>
type Bounded_String is{"\n"}   record{"\n"}      Data : Bounded_String_Internals;  -- Unconstrained{"\n"}   end record;{"\n"}
</CodeBlock>

<CodeBlock>
Null_Bounded_String : constant Bounded_String :={"\n"}   (Data ={">"} (Length ={">"} 0,{"\n"}             Data   ={">"} (1..0 ={">"} ' ')));{"\n"}
</CodeBlock>


#### Inconsistencies With Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI95-00238-01"}</em>{"}"} <strong>Amendment </strong> The bounds of the string returned from Slice are now defined. This is technically an inconsistency; if a program depended on some other lower bound for the string returned from Slice, it could fail when compiled with Ada 2005. Such code is not portable even between Ada 95 implementations, so it should be very rare. </p></Admonition>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0005-1"}</em>{"}"} Procedure Set_Bounded_String, two Bounded_Slice subprograms, and overloaded versions of Index and Index_Non_Blank are added to Strings.Bounded.Generic_Bounded_Length. If an instance of Generic_Bounded_Length is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity in Generic_Bounded_Length is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} <strong>Corrigendum:</strong> Corrected the conditions for which Slice raises Index_Error.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>8652/0049</em>{"}"} {"{"}<em>{"AI95-00128-01"}</em>{"}"} <strong>Corrigendum:</strong> Clarified the meaning of transformation, selector, and constructor subprograms by describing the effects of procedures and functions separately. </p></Admonition>


#### Incompatibilities With Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0031-1"}</em>{"}"} An overloaded version of Find_Token is added to Strings.Bounded.Generic_Bounded_Length. If an instance of Generic_Bounded_Length is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> of Find_Token is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


## A.4.5  Unbounded-Length String Handling

<p>{"{"}<em>{"AI12-0445-1"}</em>{"}"} The language-defined package Strings.Unbounded provides a private type Unbounded_String and a set of operations. An object of type Unbounded_String represents a String whose low bound is 1 and whose length can vary conceptually between 0 and Natural'Last. The subprograms for fixed-length string handling are either overloaded directly for Unbounded_String, or are modified as necessary to reflect the flexibility in length. Since the Unbounded_String type is private, relevant constructor and selector operations are provided. </p>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>The transformation operations for fixed- and bounded-length strings that are not necessarily length preserving are supplied for Unbounded_String as procedures as well as functions. This allows an implementation to do an initial allocation for an unbounded string and to avoid further allocations as long as the length does not exceed the allocated length. </p></Admonition>


#### Static Semantics

<p>The library package Strings.Unbounded has the following declaration: </p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Strings.Maps;{"\n"}package Ada.Strings.Unbounded{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00161-01"}{"}"} {"{"}{"AI12-0399-1"}{"}"}    type Unbounded_String is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   Null_Unbounded_String : constant Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Length (Source : in Unbounded_String) return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   type String_Access is access all String;{"\n"}   procedure Free (X : in out String_Access);{"\n"}
</CodeBlock>

<CodeBlock>
-- Conversion, Concatenation, and Selection functions{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Unbounded_String (Source : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Unbounded_String (Length : in Natural){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_String (Source : in Unbounded_String) return String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    procedure Set_Unbounded_String{"\n"}     (Target :    out Unbounded_String;{"\n"}      Source : in     String);{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Append (Source   : in out Unbounded_String;{"\n"}                     New_Item : in Unbounded_String);{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Append (Source   : in out Unbounded_String;{"\n"}                     New_Item : in String);{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Append (Source   : in out Unbounded_String;{"\n"}                     New_Item : in Character);{"\n"}
</CodeBlock>

<CodeBlock>
   function "&" (Left, Right : in Unbounded_String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "&" (Left : in Unbounded_String; Right : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "&" (Left : in String; Right : in Unbounded_String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "&" (Left : in Unbounded_String; Right : in Character){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "&" (Left : in Character; Right : in Unbounded_String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Element (Source : in Unbounded_String;{"\n"}                     Index  : in Positive){"\n"}      return Character;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Replace_Element (Source : in out Unbounded_String;{"\n"}                              Index  : in Positive;{"\n"}                              By     : in Character);{"\n"}
</CodeBlock>

<CodeBlock>
   function Slice (Source : in Unbounded_String;{"\n"}                   Low    : in Positive;{"\n"}                   High   : in Natural){"\n"}      return String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Unbounded_Slice{"\n"}      (Source : in Unbounded_String;{"\n"}       Low    : in Positive;{"\n"}       High   : in Natural){"\n"}          return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    procedure Unbounded_Slice{"\n"}      (Source : in     Unbounded_String;{"\n"}       Target :    out Unbounded_String;{"\n"}       Low    : in     Positive;{"\n"}       High   : in     Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   function "="  (Left, Right : in Unbounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "="  (Left : in Unbounded_String; Right : in String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "="  (Left : in String; Right : in Unbounded_String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}"  (Left, Right : in Unbounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}"  (Left : in Unbounded_String; Right : in String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}"  (Left : in String; Right : in Unbounded_String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}=" (Left, Right : in Unbounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}="  (Left : in Unbounded_String; Right : in String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}="  (Left : in String; Right : in Unbounded_String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}"  (Left, Right : in Unbounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}"  (Left : in Unbounded_String; Right : in String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}"  (Left : in String; Right : in Unbounded_String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}=" (Left, Right : in Unbounded_String) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}="  (Left : in Unbounded_String; Right : in String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{">"}="  (Left : in String; Right : in Unbounded_String){"\n"}     return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
-- Search subprograms{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in Unbounded_String;{"\n"}                   Pattern : in String;{"\n"}                   From    : in Positive;{"\n"}                   Going   : in Direction := Forward;{"\n"}                   Mapping : in Maps.Character_Mapping := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in Unbounded_String;{"\n"}                   Pattern : in String;{"\n"}                   From    : in Positive;{"\n"}                   Going   : in Direction := Forward;{"\n"}                   Mapping : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source   : in Unbounded_String;{"\n"}                   Pattern  : in String;{"\n"}                   Going    : in Direction := Forward;{"\n"}                   Mapping  : in Maps.Character_Mapping{"\n"}                                := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source   : in Unbounded_String;{"\n"}                   Pattern  : in String;{"\n"}                   Going    : in Direction := Forward;{"\n"}                   Mapping  : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index (Source  : in Unbounded_String;{"\n"}                   Set     : in Maps.Character_Set;{"\n"}                   From    : in Positive;{"\n"}                   Test    : in Membership := Inside;{"\n"}                   Going    : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index (Source : in Unbounded_String;{"\n"}                   Set    : in Maps.Character_Set;{"\n"}                   Test   : in Membership := Inside;{"\n"}                   Going  : in Direction  := Forward) return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00301-01"}{"}"}    function Index_Non_Blank (Source : in Unbounded_String;{"\n"}                             From   : in Positive;{"\n"}                             Going  : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Index_Non_Blank (Source : in Unbounded_String;{"\n"}                             Going  : in Direction := Forward){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in Unbounded_String;{"\n"}                   Pattern  : in String;{"\n"}                   Mapping  : in Maps.Character_Mapping{"\n"}                                := Maps.Identity){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in Unbounded_String;{"\n"}                   Pattern  : in String;{"\n"}                   Mapping  : in Maps.Character_Mapping_Function){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
   function Count (Source   : in Unbounded_String;{"\n"}                   Set      : in Maps.Character_Set){"\n"}      return Natural;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0031-1"}{"}"}    procedure Find_Token (Source : in Unbounded_String;{"\n"}                         Set    : in Maps.Character_Set;{"\n"}                         From   : in Positive;{"\n"}                         Test   : in Membership;{"\n"}                         First  : out Positive;{"\n"}                         Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Find_Token (Source : in Unbounded_String;{"\n"}                         Set    : in Maps.Character_Set;{"\n"}                         Test   : in Membership;{"\n"}                         First  : out Positive;{"\n"}                         Last   : out Natural);{"\n"}
</CodeBlock>

<CodeBlock>
-- String translation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
   function Translate (Source  : in Unbounded_String;{"\n"}                       Mapping : in Maps.Character_Mapping){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Translate (Source  : in out Unbounded_String;{"\n"}                        Mapping : in Maps.Character_Mapping);{"\n"}
</CodeBlock>

<CodeBlock>
   function Translate (Source  : in Unbounded_String;{"\n"}                       Mapping : in Maps.Character_Mapping_Function){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Translate (Source  : in out Unbounded_String;{"\n"}                        Mapping : in Maps.Character_Mapping_Function);{"\n"}
</CodeBlock>

<CodeBlock>
-- String transformation subprograms{"\n"}
</CodeBlock>

<CodeBlock>
   function Replace_Slice (Source   : in Unbounded_String;{"\n"}                           Low      : in Positive;{"\n"}                           High     : in Natural;{"\n"}                           By       : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Replace_Slice (Source   : in out Unbounded_String;{"\n"}                            Low      : in Positive;{"\n"}                            High     : in Natural;{"\n"}                            By       : in String);{"\n"}
</CodeBlock>

<CodeBlock>
   function Insert (Source   : in Unbounded_String;{"\n"}                    Before   : in Positive;{"\n"}                    New_Item : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Insert (Source   : in out Unbounded_String;{"\n"}                     Before   : in Positive;{"\n"}                     New_Item : in String);{"\n"}
</CodeBlock>

<CodeBlock>
   function Overwrite (Source    : in Unbounded_String;{"\n"}                       Position  : in Positive;{"\n"}                       New_Item  : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Overwrite (Source    : in out Unbounded_String;{"\n"}                        Position  : in Positive;{"\n"}                        New_Item  : in String);{"\n"}
</CodeBlock>

<CodeBlock>
   function Delete (Source  : in Unbounded_String;{"\n"}                    From    : in Positive;{"\n"}                    Through : in Natural){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Delete (Source  : in out Unbounded_String;{"\n"}                     From    : in Positive;{"\n"}                     Through : in Natural);{"\n"}
</CodeBlock>

<CodeBlock>
   function Trim (Source : in Unbounded_String;{"\n"}                  Side   : in Trim_End){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Trim (Source : in out Unbounded_String;{"\n"}                   Side   : in Trim_End);{"\n"}
</CodeBlock>

<CodeBlock>
   function Trim (Source : in Unbounded_String;{"\n"}                  Left   : in Maps.Character_Set;{"\n"}                  Right  : in Maps.Character_Set){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Trim (Source : in out Unbounded_String;{"\n"}                   Left   : in Maps.Character_Set;{"\n"}                   Right  : in Maps.Character_Set);{"\n"}
</CodeBlock>

<CodeBlock>
   function Head (Source : in Unbounded_String;{"\n"}                  Count  : in Natural;{"\n"}                  Pad    : in Character := Space){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Head (Source : in out Unbounded_String;{"\n"}                   Count  : in Natural;{"\n"}                   Pad    : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function Tail (Source : in Unbounded_String;{"\n"}                  Count  : in Natural;{"\n"}                  Pad    : in Character := Space){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Tail (Source : in out Unbounded_String;{"\n"}                   Count  : in Natural;{"\n"}                   Pad    : in Character := Space);{"\n"}
</CodeBlock>

<CodeBlock>
   function "*" (Left  : in Natural;{"\n"}                 Right : in Character){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "*" (Left  : in Natural;{"\n"}                 Right : in String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function "*" (Left  : in Natural;{"\n"}                 Right : in Unbounded_String){"\n"}      return Unbounded_String;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Unbounded;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00360-01"}</em>{"}"} The type Unbounded_String needs finalization (see 7.6).</p>
<p>Null_Unbounded_String represents the null String. If an object of type Unbounded_String is not otherwise initialized, it will be initialized to the same value as Null_Unbounded_String.</p>
<p>The function Length returns the length of the String represented by Source.</p>
<p>The type String_Access provides a (nonprivate) access type for explicit processing of unbounded-length strings. The procedure Free performs an unchecked deallocation of an object of type String_Access.</p>
<p>The function To_Unbounded_String(Source : in String) returns an Unbounded_String that represents Source. The function To_Unbounded_String(Length : in Natural) returns an Unbounded_String that represents an uninitialized String whose length is Length.</p>
<p>The function To_String returns the String with lower bound 1 represented by Source. To_String and To_Unbounded_String are related as follows: </p>
<p>If S is a String, then To_String(To_Unbounded_String(S)) = S.</p>
<p>If U is an Unbounded_String, then To_Unbounded_String(To_String(U)) = U. </p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} The procedure Set_Unbounded_String sets Target to an Unbounded_String that represents Source.</p>
<p>For each of the Append procedures, the resulting string represented by the Source parameter is given by the concatenation of the original value of Source and the value of New_Item.</p>
<p>Each of the "&" functions returns an Unbounded_String obtained by concatenating the string or character given or represented by one of the parameters, with the string or character given or represented by the other parameter, and applying To_Unbounded_String to the concatenation result string.</p>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>{"{"}<em>{"AI12-0005-1"}</em>{"}"} If the resulting string is longer than Natural'Last, Constraint_Error is raised because the upper bound of the underlying String concatenation is outside of the range of the index subtype of Natural (see 4.5.3). Note that the same is true for other operations that attempt to create an overlong string: either they are defined in terms of this concatenation operation (as with Append) or they are defined in terms of Ada.Strings.Fixed operations (as with Insert and Replace_Slice), which themselves are defined in terms of String concatenation (which raises Constraint_Error for overlong strings as described above). Therefore, it is never possible to create an Unbounded_String with a length greater than Natural'Last. </p></Admonition>

<p>The Element, Replace_Element, and Slice subprograms have the same effect as the corresponding bounded-length string subprograms.</p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} The function Unbounded_Slice returns the slice at positions Low through High in the string represented by Source as an Unbounded_String. The procedure Unbounded_Slice sets Target to the Unbounded_String representing the slice at positions Low through High in the string represented by Source. Both subprograms propagate Index_Error if Low {">"} Length(Source)+1 or High {">"} Length(Source).</p>
<p>Each of the functions "=", "{"<"}", "{">"}", "{"<"}=", and "{">"}=" returns the same result as the corresponding String operation applied to the String values given or represented by Left and Right.</p>
<p>Each of the search subprograms (Index, Index_Non_Blank, Count, Find_Token) has the same effect as the corresponding subprogram in Strings.Fixed applied to the string represented by the Unbounded_String parameter.</p>
<p>The Translate function has an analogous effect to the corresponding subprogram in Strings.Fixed. The translation is applied to the string represented by the Unbounded_String parameter, and the result is converted (via To_Unbounded_String) to an Unbounded_String.</p>
<p>Each of the transformation functions (Replace_Slice, Insert, Overwrite, Delete), selector functions (Trim, Head, Tail), and constructor functions ("*") is likewise analogous to its corresponding subprogram in Strings.Fixed. For each of the subprograms, the corresponding fixed-length string subprogram is applied to the string represented by the Unbounded_String parameter, and To_Unbounded_String is applied the result string.</p>
<p>For each of the procedures Translate, Replace_Slice, Insert, Overwrite, Delete, Trim, Head, and Tail, the resulting string represented by the Source parameter is given by the corresponding function for fixed-length strings applied to the string represented by Source's original value. </p>

#### Implementation Requirements

<p>No storage associated with an Unbounded_String object shall be lost upon assignment or scope exit. </p>
<Admonition type="aarm" aarm="implementation-note" title="Implementation Note: ">
<p><strong></strong>{"{"}<em>{"AI95-00301-01"}</em>{"}"} A sample implementation of the private part of the package and several of the subprograms appears in the Ada 95 Rationale.</p></Admonition>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI95-00360-01"}</em>{"}"} <strong>Amendment </strong> Type Unbounded_String is defined to need finalization. If the restriction No_Nested_Finalization (see D.7) applies to the partition, and Unbounded_String does not have a controlled part, it will not be allowed in local objects in Ada 2005 whereas it would be allowed in original Ada 95. Such code is not portable, as most Ada compilers have a controlled part in Unbounded_String, and thus would be illegal.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} {"{"}<em>{"AI05-0005-1"}</em>{"}"} Procedure Set_Unbounded_String, two Unbounded_Slice subprograms, and overloaded versions of Index and Index_Non_Blank are added to Strings.Unbounded. If Strings.Unbounded is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity in Strings.Unbounded is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} <strong>Amendment </strong> Added a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization to type Unbounded_String, so that it can be used to declare default-initialized objects in preelaborated units. </p></Admonition>


#### Incompatibilities With Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0031-1"}</em>{"}"} An overloaded version of Find_Token is added to Strings.Unbounded. If Strings.Unbounded is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> of Find_Token is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


## A.4.6  String-Handling Sets and Mappings

<p>The language-defined package Strings.Maps.Constants declares Character_Set and Character_Mapping constants corresponding to classification and conversion functions in package Characters.Handling. </p>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<p><strong></strong>The Constants package is a child of Strings.Maps since it needs visibility of the private part of Strings.Maps in order to initialize the constants in a preelaborable way (i.e. via aggregates versus function calls). </p></Admonition>


#### Static Semantics

<p>The library package Strings.Maps.Constants has the following declaration:</p>
<CodeBlock>
{"{"}{"AI95-00362-01"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.Maps.Constants{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   Control_Set           : constant Character_Set;{"\n"}   Graphic_Set           : constant Character_Set;{"\n"}   Letter_Set            : constant Character_Set;{"\n"}   Lower_Set             : constant Character_Set;{"\n"}   Upper_Set             : constant Character_Set;{"\n"}   Basic_Set             : constant Character_Set;{"\n"}   Decimal_Digit_Set     : constant Character_Set;{"\n"}   Hexadecimal_Digit_Set : constant Character_Set;{"\n"}   Alphanumeric_Set      : constant Character_Set;{"\n"}   Special_Set           : constant Character_Set;{"\n"}   ISO_646_Set           : constant Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   Lower_Case_Map        : constant Character_Mapping;{"\n"}     --Maps to lower case for letters, else identity{"\n"}   Upper_Case_Map        : constant Character_Mapping;{"\n"}     --Maps to upper case for letters, else identity{"\n"}   Basic_Map             : constant Character_Mapping;{"\n"}     --Maps to basic letter for letters, else identity{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Maps.Constants;{"\n"}
</CodeBlock>

<p>Each of these constants represents a correspondingly named set of characters or character mapping in Characters.Handling (see A.3.2). </p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE   {"{"}<em>{"AI05-0114-1"}</em>{"}"} There are certain characters which are defined to be lower case letters by ISO 10646 and are therefore allowed in identifiers, but are not considered lower case letters by Ada.Strings.Maps.Constants.</p></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<p><strong></strong>This is to maintain runtime compatibility with the Ada 95 definitions of these constants; existing correct programs could break if the definitions were changed in a way the programs did not anticipate. </p></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00362-01"}</em>{"}"} Strings.Maps.Constants is now Pure, so it can be used in pure units. </p></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI05-0114-1"}</em>{"}"} <strong></strong> Added a note to clarify that these constants don't have any relationship to the characters allowed in identifiers. </p></Admonition>


## A.4.7  Wide_String Handling

<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} Facilities for handling strings of Wide_Character elements are found in the packages Strings.Wide_Maps, Strings.Wide_Fixed, Strings.Wide_Bounded, Strings.Wide_Unbounded, and Strings.Wide_Maps.Wide_Constants, and in the library functions Strings.Wide_Hash, Strings.Wide_Fixed.Wide_Hash, Strings.Wide_Bounded.Wide_Hash, Strings.Wide_Unbounded.Wide_Hash, Strings.Wide_Hash_Case_Insensitive, Strings.Wide_Fixed.Wide_Hash_Case_Insensitive, Strings.Wide_Bounded.Wide_Hash_Case_Insensitive, Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive, Strings.Wide_Equal_Case_Insensitive, Strings.Wide_Fixed.Wide_Equal_Case_Insensitive, Strings.Wide_Bounded.Wide_Equal_Case_Insensitive, and Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive. They provide the same string-handling operations as the corresponding packages and functions for strings of Character elements. </p>

#### Static Semantics

<p>The package Strings.Wide_Maps has the following declaration. </p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} package Ada.Strings.Wide_Maps{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00161-01"}{"}"} {"{"}{"AI12-0399-1"}{"}"}    -- Representation for a set of Wide_Character values:{"\n"}   type Wide_Character_Set is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   Null_Set : constant Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Character_Range is{"\n"}     record{"\n"}         Low  : Wide_Character;{"\n"}         High : Wide_Character;{"\n"}     end record;{"\n"}   -- Represents Wide_Character range Low..High{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Character_Ranges is array (Positive range {"<"}{">"}){"\n"}      of Wide_Character_Range;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set    (Ranges : in Wide_Character_Ranges){"\n"}      return Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set    (Span   : in Wide_Character_Range){"\n"}      return Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Ranges (Set    : in Wide_Character_Set){"\n"}      return Wide_Character_Ranges;{"\n"}
</CodeBlock>

<CodeBlock>
   function "="   (Left, Right : in Wide_Character_Set) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "not" (Right : in Wide_Character_Set){"\n"}      return Wide_Character_Set;{"\n"}   function "and" (Left, Right : in Wide_Character_Set){"\n"}      return Wide_Character_Set;{"\n"}   function "or"  (Left, Right : in Wide_Character_Set){"\n"}      return Wide_Character_Set;{"\n"}   function "xor" (Left, Right : in Wide_Character_Set){"\n"}      return Wide_Character_Set;{"\n"}   function "-"   (Left, Right : in Wide_Character_Set){"\n"}      return Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_In (Element : in Wide_Character;{"\n"}                   Set     : in Wide_Character_Set){"\n"}      return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_Subset (Elements : in Wide_Character_Set;{"\n"}                       Set      : in Wide_Character_Set){"\n"}      return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}=" (Left  : in Wide_Character_Set;{"\n"}                  Right : in Wide_Character_Set){"\n"}      return Boolean renames Is_Subset;{"\n"}
</CodeBlock>

<CodeBlock>
   -- Alternative representation for a set of Wide_Character values:{"\n"}   subtype Wide_Character_Sequence is Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Sequence  : in Wide_Character_Sequence){"\n"}      return Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Singleton : in Wide_Character){"\n"}      return Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Sequence (Set  : in Wide_Character_Set){"\n"}      return Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI95-00161-01"}{"}"} {"{"}{"AI12-0399-1"}{"}"}    -- Representation for a Wide_Character to Wide_Character mapping:{"\n"}   type Wide_Character_Mapping is private{"\n"}       with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   function Value (Map     : in Wide_Character_Mapping;{"\n"}                   Element : in Wide_Character){"\n"}      return Wide_Character;{"\n"}
</CodeBlock>

<CodeBlock>
   Identity : constant Wide_Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Mapping (From, To : in Wide_Character_Sequence){"\n"}      return Wide_Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Domain (Map : in Wide_Character_Mapping){"\n"}      return Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Range  (Map : in Wide_Character_Mapping){"\n"}      return Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Character_Mapping_Function is{"\n"}      access function (From : in Wide_Character) return Wide_Character;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Wide_Maps;{"\n"}
</CodeBlock>

<p>The context clause for each of the packages Strings.Wide_Fixed, Strings.Wide_Bounded, and Strings.Wide_Unbounded identifies Strings.Wide_Maps instead of Strings.Maps.</p>
<p>{"{"}<em>{"AI05-0223-1"}</em>{"}"} Types Wide_Character_Set and Wide_Character_Mapping need finalization.</p>
<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} For each of the packages Strings.Fixed, Strings.Bounded, Strings.Unbounded, and Strings.Maps.Constants, and for library functions Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash, Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive, Strings.Fixed.Hash_Case_Insensitive, Strings.Bounded.Hash_Case_Insensitive, Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive, Strings.Fixed.Equal_Case_Insensitive, Strings.Bounded.Equal_Case_Insensitive, and Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide string package or function has the same contents except that </p>
<p>Wide_Space replaces Space</p>
<p>Wide_Character replaces Character</p>
<p>Wide_String replaces String</p>
<p>Wide_Character_Set replaces Character_Set</p>
<p>Wide_Character_Mapping replaces Character_Mapping</p>
<p>Wide_Character_Mapping_Function replaces Character_Mapping_Function</p>
<p>Wide_Maps replaces Maps</p>
<p>Bounded_Wide_String replaces Bounded_String</p>
<p>Null_Bounded_Wide_String replaces Null_Bounded_String</p>
<p>To_Bounded_Wide_String replaces To_Bounded_String</p>
<p>To_Wide_String replaces To_String</p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Set_Bounded_Wide_String replaces Set_Bounded_String</p>
<p>Unbounded_Wide_String replaces Unbounded_String</p>
<p>Null_Unbounded_Wide_String replaces Null_Unbounded_String</p>
<p>Wide_String_Access replaces String_Access</p>
<p>To_Unbounded_Wide_String replaces To_Unbounded_String</p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Set_Unbounded_Wide_String replaces Set_Unbounded_String</p>
<p>The following additional declaration is present in Strings.Wide_Maps.Wide_Constants: </p>
<CodeBlock>
{"{"}{"AI95-00285-01"}{"}"} {"{"}{"AI95-00395-01"}{"}"} Character_Set : constant Wide_Maps.Wide_Character_Set;{"\n"}--Contains each Wide_Character value WC such that{"\n"}--Characters.Conversions.Is_Character(WC) is True{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00395-01"}</em>{"}"} Each Wide_Character_Set constant in the package Strings.Wide_Maps.Wide_Constants contains no values outside the Character portion of Wide_Character. Similarly, each Wide_Character_Mapping constant in this package is the identity mapping when applied to any element outside the Character portion of Wide_Character.</p>
<p>{"{"}<em>{"AI95-00362-01"}</em>{"}"} {"{"}<em>{"AI12-0302-1"}</em>{"}"} {"{"}<em>{"AI12-0414-1"}</em>{"}"} Aspect Pure is replaced by aspects Preelaborate, Nonblocking, Global ={">"} <strong>in out synchronized</strong> in Strings.Wide_Maps.Wide_Constants. </p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE   If a null Wide_Character_Mapping_Function is passed to any of the Wide_String handling subprograms, Constraint_Error is propagated.</p></Admonition>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Various new operations are added to Strings.Wide_Fixed, Strings.Wide_Bounded, and Strings.Wide_Unbounded. If one of these packages is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. </p></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} <strong>Amendment </strong> Added <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization to types Wide_Character_Set and Wide_Character_Mapping, so that they can be used to declare default-initialized objects in preelaborated units. </p></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} Corrected the description of Character_Set.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} Added wide versions of Strings.Hash and Strings.Unbounded.Hash.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00362-01"}</em>{"}"} Added wording so that Strings.Wide_Maps.Wide_Constants does not change to Pure.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00395-01"}</em>{"}"} The second Note is now normative text, since there is no way to derive it from the other rules. It's a little weird given the use of Unicode character classifications in Ada 2005; but changing it would be inconsistent with Ada 95 and a one-to-one mapping isn't necessarily correct anyway. </p></Admonition>


#### Extensions to Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0286-1"}</em>{"}"} The case insenstive library functions (Strings.Wide_Equal_Case_Insensitive, Strings.Wide_Fixed.Wide_Equal_Case_Insensitive, Strings.Wide_Bounded.Wide_Equal_Case_Insensitive, Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive, Strings.Wide_Hash_Case_Insensitive, Strings.Wide_Fixed.Wide_Hash_Case_Insensitive, Strings.Wide_Bounded.Wide_Hash_Case_Insensitive, and Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive) are new. </p></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0223-1"}</em>{"}"} <strong>Correction</strong>: Identified Wide_Character_Set and Wide_Character_Mapping as needing finalization. It is likely that they are implemented with a controlled type, so this change is unlikely to make any difference in practice. </p></Admonition>


## A.4.8  Wide_Wide_String Handling

<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI95-00395-01"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} Facilities for handling strings of Wide_Wide_Character elements are found in the packages Strings.Wide_Wide_Maps, Strings.Wide_Wide_Fixed, Strings.Wide_Wide_Bounded, Strings.Wide_Wide_Unbounded, and Strings.Wide_Wide_Maps.Wide_Wide_Constants, and in the library functions Strings.Wide_Wide_Hash, Strings.Wide_Wide_Fixed.Wide_Wide_Hash, Strings.Wide_Wide_Bounded.Wide_Wide_Hash, Strings.Wide_Wide_Unbounded.Wide_Wide_Hash, Strings.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive, and Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive. They provide the same string-handling operations as the corresponding packages and functions for strings of Character elements. </p>

#### Static Semantics

<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} The library package Strings.Wide_Wide_Maps has the following declaration.</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} package Ada.Strings.Wide_Wide_Maps{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI12-0399-1"}{"}"}    -- Representation for a set of Wide_Wide_Character values:{"\n"}   type Wide_Wide_Character_Set is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   Null_Set : constant Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Wide_Character_Range is{"\n"}      record{"\n"}         Low  : Wide_Wide_Character;{"\n"}         High : Wide_Wide_Character;{"\n"}      end record;{"\n"}   -- Represents Wide_Wide_Character range Low..High{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Wide_Character_Ranges is array (Positive range {"<"}{">"}){"\n"}         of Wide_Wide_Character_Range;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Ranges : in Wide_Wide_Character_Ranges){"\n"}         return Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Span : in Wide_Wide_Character_Range){"\n"}         return Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Ranges (Set : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Ranges;{"\n"}
</CodeBlock>

<CodeBlock>
   function "=" (Left, Right : in Wide_Wide_Character_Set) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "not" (Right : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Set;{"\n"}   function "and" (Left, Right : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Set;{"\n"}   function "or" (Left, Right : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Set;{"\n"}   function "xor" (Left, Right : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Set;{"\n"}   function "-" (Left, Right : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_In (Element : in Wide_Wide_Character;{"\n"}                   Set     : in Wide_Wide_Character_Set){"\n"}         return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function Is_Subset (Elements : in Wide_Wide_Character_Set;{"\n"}                       Set      : in Wide_Wide_Character_Set){"\n"}         return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   function "{"<"}=" (Left  : in Wide_Wide_Character_Set;{"\n"}                  Right : in Wide_Wide_Character_Set){"\n"}         return Boolean renames Is_Subset;{"\n"}
</CodeBlock>

<CodeBlock>
   -- Alternative representation for a set of Wide_Wide_Character values:{"\n"}   subtype Wide_Wide_Character_Sequence is Wide_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Sequence : in Wide_Wide_Character_Sequence){"\n"}         return Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Set (Singleton : in Wide_Wide_Character){"\n"}         return Wide_Wide_Character_Set;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Sequence (Set : in Wide_Wide_Character_Set){"\n"}         return Wide_Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI12-0399-1"}{"}"}    -- Representation for a Wide_Wide_Character to Wide_Wide_Character{"\n"}   -- mapping:{"\n"}   type Wide_Wide_Character_Mapping is private{"\n"}      with Preelaborable_Initialization;{"\n"}
</CodeBlock>

<CodeBlock>
   function Value (Map     : in Wide_Wide_Character_Mapping;{"\n"}                   Element : in Wide_Wide_Character){"\n"}         return Wide_Wide_Character;{"\n"}
</CodeBlock>

<CodeBlock>
   Identity : constant Wide_Wide_Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Mapping (From, To : in Wide_Wide_Character_Sequence){"\n"}         return Wide_Wide_Character_Mapping;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Domain (Map : in Wide_Wide_Character_Mapping){"\n"}         return Wide_Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
   function To_Range (Map : in Wide_Wide_Character_Mapping){"\n"}         return Wide_Wide_Character_Sequence;{"\n"}
</CodeBlock>

<CodeBlock>
   type Wide_Wide_Character_Mapping_Function is{"\n"}         access function (From : in Wide_Wide_Character){"\n"}         return Wide_Wide_Character;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Wide_Wide_Maps;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} The context clause for each of the packages Strings.Wide_Wide_Fixed, Strings.Wide_Wide_Bounded, and Strings.Wide_Wide_Unbounded identifies Strings.Wide_Wide_Maps instead of Strings.Maps.</p>
<p>{"{"}<em>{"AI05-0223-1"}</em>{"}"} Types Wide_Wide_Character_Set and Wide_Wide_Character_Mapping need finalization.</p>
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} For each of the packages Strings.Fixed, Strings.Bounded, Strings.Unbounded, and Strings.Maps.Constants, and for library functions Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash, Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive, Strings.Fixed.Hash_Case_Insensitive, Strings.Bounded.Hash_Case_Insensitive, Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive, Strings.Fixed.Equal_Case_Insensitive, Strings.Bounded.Equal_Case_Insensitive, and Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide wide string package or function has the same contents except that</p>
<p>Wide_Wide_Space replaces Space</p>
<p>Wide_Wide_Character replaces Character</p>
<p>Wide_Wide_String replaces String</p>
<p>Wide_Wide_Character_Set replaces Character_Set</p>
<p>Wide_Wide_Character_Mapping replaces Character_Mapping</p>
<p>Wide_Wide_Character_Mapping_Function replaces Character_Mapping_Function</p>
<p>Wide_Wide_Maps replaces Maps</p>
<p>Bounded_Wide_Wide_String replaces Bounded_String</p>
<p>Null_Bounded_Wide_Wide_String replaces Null_Bounded_String</p>
<p>To_Bounded_Wide_Wide_String replaces To_Bounded_String</p>
<p>To_Wide_Wide_String replaces To_String</p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Set_Bounded_Wide_Wide_String replaces Set_Bounded_String</p>
<p>Unbounded_Wide_Wide_String replaces Unbounded_String</p>
<p>Null_Unbounded_Wide_Wide_String replaces Null_Unbounded_String</p>
<p>Wide_Wide_String_Access replaces String_Access</p>
<p>To_Unbounded_Wide_Wide_String replaces To_Unbounded_String</p>
<p>{"{"}<em>{"AI95-00301-01"}</em>{"}"} Set_Unbounded_Wide_Wide_String replaces Set_Unbounded_String</p>
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI95-00395-01"}</em>{"}"} The following additional declarations are present in Strings.Wide_Wide_Maps.Wide_Wide_Constants:</p>
<CodeBlock>
Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;{"\n"}-- Contains each Wide_Wide_Character value WWC such that{"\n"}-- Characters.Conversions.Is_Character(WWC) is True{"\n"}Wide_Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;{"\n"}-- Contains each Wide_Wide_Character value WWC such that{"\n"}-- Characters.Conversions.Is_Wide_Character(WWC) is True{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00395-01"}</em>{"}"} Each Wide_Wide_Character_Set constant in the package Strings.Wide_Wide_Maps.Wide_Wide_Constants contains no values outside the Character portion of Wide_Wide_Character. Similarly, each Wide_Wide_Character_Mapping constant in this package is the identity mapping when applied to any element outside the Character portion of Wide_Wide_Character.</p>
<p>{"{"}<em>{"AI95-00395-01"}</em>{"}"} {"{"}<em>{"AI12-0302-1"}</em>{"}"} {"{"}<em>{"AI12-0414-1"}</em>{"}"} Aspect Pure is replaced by aspects Preelaborate, Nonblocking, Global ={">"} <strong>in out synchronized</strong> in Strings.Wide_Wide_Maps.Wide_Wide_Constants.</p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 1   {"{"}<em>{"AI95-00285-01"}</em>{"}"} If a null Wide_Wide_Character_Mapping_Function is passed to any of the Wide_Wide_String handling subprograms, Constraint_Error is propagated. </p></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00285-01"}</em>{"}"} {"{"}<em>{"AI95-00395-01"}</em>{"}"} The double-wide string-handling packages (Strings.Wide_Wide_Maps, Strings.Wide_Wide_Fixed, Strings.Wide_Wide_Bounded, Strings.Wide_Wide_Unbounded, and Strings.Wide_Wide_Maps.Wide_Wide_Constants), and functions Strings.Wide_Wide_Hash and Strings.Wide_Wide_Unbounded.Wide_Wide_Hash are new. </p></Admonition>


#### Extensions to Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0286-1"}</em>{"}"} The case insenstive library functions (Strings.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive, Strings.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive, Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive, and Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive) are new. </p></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0223-1"}</em>{"}"} <strong>Correction</strong>: Identified Wide_Wide_Character_Set and Wide_Wide_Character_Mapping as needing finalization. It is likely that they are implemented with a controlled type, so this change is unlikely to make any difference in practice. </p></Admonition>


## A.4.9  String Hashing


#### Static Semantics

<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The library function Strings.Hash has the following declaration: </p>
<CodeBlock>
{"{"}{"AI05-0298-1"}{"}"} {"{"}{"AI12-0414-1"}{"}"} with Ada.Containers;{"\n"}function Ada.Strings.Hash (Key : String) return Containers.Hash_Type{"\n"}   with Pure;{"\n"}
</CodeBlock>

<p>Returns an implementation-defined value which is a function of the value of Key. If <em>A</em> and <em>B</em> are strings such that <em>A</em> equals <em>B</em>, Hash(<em>A</em>) equals Hash(<em>B</em>). </p>
<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<p><strong></strong>The values returned by Strings.Hash.</p></Admonition>

<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The library function Strings.Fixed.Hash has the following declaration: </p>
<CodeBlock>
{"{"}{"AI05-0298-1"}{"}"} with Ada.Containers, Ada.Strings.Hash;{"\n"}function Ada.Strings.Fixed.Hash (Key : String) return Containers.Hash_Type{"\n"}   renames Ada.Strings.Hash;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The generic library function Strings.Bounded.Hash has the following declaration: </p>
<CodeBlock>
{"{"}{"AI05-0298-1"}{"}"} {"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Containers;{"\n"}generic{"\n"}   with package Bounded is{"\n"}      new Ada.Strings.Bounded.Generic_Bounded_Length ({"<"}{">"});{"\n"}function Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String){"\n"}   return Containers.Hash_Type{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} Equivalent to Strings.Hash (Bounded.To_String (Key));</p>
<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The library function Strings.Unbounded.Hash has the following declaration: </p>
<CodeBlock>
{"{"}{"AI05-0298-1"}{"}"} {"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Containers;{"\n"}function Ada.Strings.Unbounded.Hash (Key : Unbounded_String){"\n"}   return Containers.Hash_Type{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} Equivalent to Strings.Hash (To_String (Key));</p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Hash_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0414-1"}{"}"} with Ada.Containers;{"\n"}function Ada.Strings.Hash_Case_Insensitive (Key : String){"\n"}   return Containers.Hash_Type{"\n"}   with Pure;{"\n"}
</CodeBlock>

<p>Returns an implementation-defined value which is a function of the value of Key, converted to lower case. If A and B are strings such that Strings.Equal_Case_Insensitive (A, B) (see A.4.10) is True, then Hash_Case_Insensitive(A) equals Hash_Case_Insensitive(B). </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Fixed.Hash_Case_Insensitive has the following declaration:</p>
<CodeBlock>
with Ada.Containers, Ada.Strings.Hash_Case_Insensitive;{"\n"}function Ada.Strings.Fixed.Hash_Case_Insensitive (Key : String){"\n"}   return Containers.Hash_Type renames Ada.Strings.Hash_Case_Insensitive;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The generic library function Strings.Bounded.Hash_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Containers;{"\n"}generic{"\n"}   with package Bounded is{"\n"}      new Ada.Strings.Bounded.Generic_Bounded_Length ({"<"}{">"});{"\n"}function Ada.Strings.Bounded.Hash_Case_Insensitive{"\n"}   (Key : Bounded.Bounded_String) return Containers.Hash_Type{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Hash_Case_Insensitive (Bounded.To_String (Key)); </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Unbounded.Hash_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} with Ada.Containers;{"\n"}function Ada.Strings.Unbounded.Hash_Case_Insensitive{"\n"}   (Key : Unbounded_String) return Containers.Hash_Type{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Hash_Case_Insensitive (To_String (Key)); </p>

#### Implementation Advice

<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The Hash functions should be good hash functions, returning a wide spread of values for different string values. It should be unlikely for similar strings to return the same value. </p>
<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<p><strong></strong>Strings.Hash should be good a hash function, returning a wide spread of values for different string values, and similar strings should rarely return the same value.</p></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>The other functions are defined in terms of Strings.Hash, so they don't need separate advice in the Annex. </p></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI95-00302-03"}</em>{"}"} The Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash, and Strings.Unbounded.Hash functions are new. </p></Admonition>


#### Extensions to Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} The Strings.Hash_Case_Insensitive, Strings.Fixed.Hash_Case_Insensitive, Strings.Bounded.Hash_Case_Insensitive, and Strings.Unbounded.Hash_Case_Insensitive functions are new. </p></Admonition>


## A.4.10  String Comparison


#### Static Semantics

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Equal_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0414-1"}{"}"} function Ada.Strings.Equal_Case_Insensitive (Left, Right : String){"\n"}   return Boolean with Pure;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI12-0263-1"}</em>{"}"} Returns True if the strings consist of the same sequence of characters after applying locale-independent simple case folding, as defined by documents referenced in Clause 2 of ISO/IEC 10646:2017. Otherwise, returns False. This function uses the same method as is used to determine whether two identifiers are the same.</p>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<p><strong></strong>{"{"}<em>{"AI05-0286-1"}</em>{"}"} For String, this is equivalent to converting to lower case and comparing. Not so for other string types. For Wide_Strings and Wide_Wide_Strings, note that this result is a more accurate comparison than converting the strings to lower case and comparing the results; it is possible that the lower case conversions are the same but this routine will report the strings as different. Additionally, Unicode says that the result of this function will never change for strings made up solely of defined code points; there is no such guarantee for case conversion to lower case.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI12-0263-1"}</em>{"}"} The "documents referenced" means Unicode, Chapter 4 (specifically, section 4.2 - Case). See the Implementation Notes in subclause 2.3 for a source for machine-readable definitions of these properties. </p></Admonition>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Fixed.Equal_Case_Insensitive has the following declaration:</p>
<CodeBlock>
with Ada.Strings.Equal_Case_Insensitive;{"\n"}function Ada.Strings.Fixed.Equal_Case_Insensitive{"\n"}   (Left, Right : String) return Boolean{"\n"}      renames Ada.Strings.Equal_Case_Insensitive;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The generic library function Strings.Bounded.Equal_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} generic{"\n"}   with package Bounded is{"\n"}      new Ada.Strings.Bounded.Generic_Bounded_Length ({"<"}{">"});{"\n"}function Ada.Strings.Bounded.Equal_Case_Insensitive{"\n"}   (Left, Right : Bounded.Bounded_String) return Boolean{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Equal_Case_Insensitive (Bounded.To_String (Left), Bounded.To_String (Right)); </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Unbounded.Equal_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} function Ada.Strings.Unbounded.Equal_Case_Insensitive{"\n"}   (Left, Right : Unbounded_String) return Boolean{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Equal_Case_Insensitive (To_String (Left), To_String (Right)); </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Less_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0414-1"}{"}"} function Ada.Strings.Less_Case_Insensitive (Left, Right : String){"\n"}   return Boolean with Pure;{"\n"}
</CodeBlock>

<p>Performs a lexicographic comparison of strings Left and Right, converted to lower case. </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Fixed.Less_Case_Insensitive has the following declaration:</p>
<CodeBlock>
with Ada.Strings.Less_Case_Insensitive;{"\n"}function Ada.Strings.Fixed.Less_Case_Insensitive{"\n"}   (Left, Right : String) return Boolean{"\n"}      renames Ada.Strings.Less_Case_Insensitive;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The generic library function Strings.Bounded.Less_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} generic{"\n"}   with package Bounded is{"\n"}      new Ada.Strings.Bounded.Generic_Bounded_Length ({"<"}{">"});{"\n"}function Ada.Strings.Bounded.Less_Case_Insensitive{"\n"}  (Left, Right : Bounded.Bounded_String) return Boolean{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Less_Case_Insensitive (Bounded.To_String (Left), Bounded.To_String (Right)); </p>
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0248-1"}</em>{"}"} {"{"}<em>{"AI05-0298-1"}</em>{"}"} The library function Strings.Unbounded.Less_Case_Insensitive has the following declaration:</p>
<CodeBlock>
{"{"}{"AI12-0241-1"}{"}"} {"{"}{"AI12-0302-1"}{"}"} function Ada.Strings.Unbounded.Less_Case_Insensitive{"\n"}  (Left, Right : Unbounded_String) return Boolean{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized;{"\n"}
</CodeBlock>

<p>Equivalent to Strings.Less_Case_Insensitive (To_String (Left), To_String (Right)); </p>

#### Extensions to Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0001-1"}</em>{"}"} {"{"}<em>{"AI05-0286-1"}</em>{"}"} The Strings.Equal_Case_Insensitive, Strings.Fixed.Equal_Case_Insensitive, Strings.Bounded.Equal_Case_Insensitive, Strings.Unbounded.Equal_Case_Insensitive, Strings.Less_Case_Insensitive, Strings.Fixed.Less_Case_Insensitive, Strings.Bounded.Less_Case_Insensitive, Strings.Unbounded.Less_Case_Insensitive functions are new. </p></Admonition>


## A.4.11  String Encoding

<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} Facilities for encoding, decoding, and converting strings in various character encoding schemes are provided by packages Strings.UTF_Encoding, Strings.UTF_Encoding.Conversions, Strings.UTF_Encoding.Strings, Strings.UTF_Encoding.Wide_Strings, and Strings.UTF_Encoding.Wide_Wide_Strings. </p>

#### Static Semantics

<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} The encoding library packages have the following declarations:</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.UTF_Encoding{"\n"}  with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   -- Declarations common to the string encoding packages{"\n"}   type Encoding_Scheme is (UTF_8, UTF_16BE, UTF_16LE);{"\n"}
</CodeBlock>

<CodeBlock>
   subtype UTF_String is String;{"\n"}
</CodeBlock>

<CodeBlock>
   subtype UTF_8_String is String;{"\n"}
</CodeBlock>

<CodeBlock>
   subtype UTF_16_Wide_String is Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   Encoding_Error : exception;{"\n"}
</CodeBlock>

<CodeBlock>
   BOM_8    : constant UTF_8_String :={"\n"}                Character'Val(16#EF#) &{"\n"}                Character'Val(16#BB#) &{"\n"}                Character'Val(16#BF#);{"\n"}
</CodeBlock>

<CodeBlock>
   BOM_16BE : constant UTF_String :={"\n"}                Character'Val(16#FE#) &{"\n"}                Character'Val(16#FF#);{"\n"}
</CodeBlock>

<CodeBlock>
   BOM_16LE : constant UTF_String :={"\n"}                Character'Val(16#FF#) &{"\n"}                Character'Val(16#FE#);{"\n"}
</CodeBlock>

<CodeBlock>
   BOM_16   : constant UTF_16_Wide_String :={"\n"}               (1 ={">"} Wide_Character'Val(16#FEFF#));{"\n"}
</CodeBlock>

<CodeBlock>
   function Encoding (Item    : UTF_String;{"\n"}                      Default : Encoding_Scheme := UTF_8){"\n"}      return Encoding_Scheme;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.UTF_Encoding;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.UTF_Encoding.Conversions{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   -- Conversions between various encoding schemes{"\n"}   function Convert (Item          : UTF_String;{"\n"}                     Input_Scheme  : Encoding_Scheme;{"\n"}                     Output_Scheme : Encoding_Scheme;{"\n"}                     Output_BOM    : Boolean := False) return UTF_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Convert (Item          : UTF_String;{"\n"}                     Input_Scheme  : Encoding_Scheme;{"\n"}                     Output_BOM    : Boolean := False){"\n"}      return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Convert (Item          : UTF_8_String;{"\n"}                     Output_BOM    : Boolean := False){"\n"}      return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Convert (Item          : UTF_16_Wide_String;{"\n"}                     Output_Scheme : Encoding_Scheme;{"\n"}                     Output_BOM    : Boolean := False) return UTF_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Convert (Item          : UTF_16_Wide_String;{"\n"}                     Output_BOM    : Boolean := False) return UTF_8_String;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.UTF_Encoding.Conversions;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.UTF_Encoding.Strings{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   -- Encoding / decoding between String and various encoding schemes{"\n"}   function Encode (Item          : String;{"\n"}                    Output_Scheme : Encoding_Scheme;{"\n"}                    Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : String;{"\n"}                    Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : String;{"\n"}                    Output_BOM : Boolean  := False){"\n"}      return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item         : UTF_String;{"\n"}                    Input_Scheme : Encoding_Scheme) return String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_8_String) return String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_16_Wide_String) return String;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.UTF_Encoding.Strings;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.UTF_Encoding.Wide_Strings{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   -- Encoding / decoding between Wide_String and various encoding schemes{"\n"}   function Encode (Item          : Wide_String;{"\n"}                    Output_Scheme : Encoding_Scheme;{"\n"}                    Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : Wide_String;{"\n"}                    Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : Wide_String;{"\n"}                    Output_BOM : Boolean  := False){"\n"}      return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item         : UTF_String;{"\n"}                    Input_Scheme : Encoding_Scheme) return Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_8_String) return Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_16_Wide_String) return Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.UTF_Encoding.Wide_Strings;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} {"{"}{"AI12-0414-1"}{"}"} package Ada.Strings.UTF_Encoding.Wide_Wide_Strings{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   -- Encoding / decoding between Wide_Wide_String and various encoding schemes{"\n"}   function Encode (Item          : Wide_Wide_String;{"\n"}                    Output_Scheme : Encoding_Scheme;{"\n"}                    Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : Wide_Wide_String;{"\n"}                    Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Encode (Item       : Wide_Wide_String;{"\n"}                    Output_BOM : Boolean  := False){"\n"}      return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item         : UTF_String;{"\n"}                    Input_Scheme : Encoding_Scheme) return Wide_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_8_String) return Wide_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
   function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;{"\n"}
</CodeBlock>

<CodeBlock>
end Ada.Strings.UTF_Encoding.Wide_Wide_Strings;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} The type Encoding_Scheme defines encoding schemes. UTF_8 corresponds to the UTF-8 encoding scheme defined by Annex D of ISO/IEC 10646. UTF_16BE corresponds to the UTF-16 encoding scheme defined by Annex C of ISO/IEC 10646 in 8 bit, big-endian order; and UTF_16LE corresponds to the UTF-16 encoding scheme in 8 bit, little-endian order.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} The subtype UTF_String is used to represent a String of 8-bit values containing a sequence of values encoded in one of three ways (UTF-8, UTF-16BE, or UTF-16LE). The subtype UTF_8_String is used to represent a String of 8-bit values containing a sequence of values encoded in UTF-8. The subtype UTF_16_Wide_String is used to represent a Wide_String of 16-bit values containing a sequence of values encoded in UTF-16.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} The BOM_8, BOM_16BE, BOM_16LE, and BOM_16 constants correspond to values used at the start of a string to indicate the encoding.</p>
<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} {"{"}<em>{"AI05-0269-1"}</em>{"}"} Each of the Encode functions takes a String, Wide_String, or Wide_Wide_String Item parameter that is assumed to be an array of unencoded characters. Each of the Convert functions takes a UTF_String, UTF_8_String, or UTF_16_String Item parameter that is assumed to contain characters whose position values correspond to a valid encoding sequence according to the encoding scheme required by the function or specified by its Input_Scheme parameter.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} {"{"}<em>{"AI05-0269-1"}</em>{"}"} Each of the Convert and Encode functions returns a UTF_String, UTF_8_String, or UTF_16_String value whose characters have position values that correspond to the encoding of the Item parameter according to the encoding scheme required by the function or specified by its Output_Scheme parameter. For UTF_8, no overlong encoding is returned. A BOM is included at the start of the returned string if the Output_BOM parameter is set to True. The lower bound of the returned string is 1.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} Each of the Decode functions takes a UTF_String, UTF_8_String, or UTF_16_String Item parameter which is assumed to contain characters whose position values correspond to a valid encoding sequence according to the encoding scheme required by the function or specified by its Input_Scheme parameter, and returns the corresponding String, Wide_String, or Wide_Wide_String value. The lower bound of the returned string is 1.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0262-1"}</em>{"}"} For each of the Convert and Decode functions, an initial BOM in the input that matches the expected encoding scheme is ignored, and a different initial BOM causes Encoding_Error to be propagated.</p>
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} The exception Encoding_Error is also propagated in the following situations: </p>
<p>{"{"}<em>{"AI12-0088-1"}</em>{"}"} By a Convert or Decode function when a UTF encoded string contains an invalid encoding sequence.</p>
<Admonition type="aarm" aarm="note" title="Note: ">
<p><strong>To be honest: </strong>{"{"}<em>{"AI12-0088-1"}</em>{"}"} An overlong encoding is not invalid for the purposes of this check, and this does not depend on the character set version in use. Some recent character set standards declare overlong encodings to be invalid; it would be unnecessary and unfriendly to users for Convert or Decode to raise an exception for an overlong encoding. </p></Admonition>

<p>{"{"}<em>{"AI12-0088-1"}</em>{"}"} By a Convert or Decode function when the expected encoding is UTF-16BE or UTF-16LE and the input string has an odd length.</p>
<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} By a Decode function yielding a String when the decoding of a sequence results in a code point whose value exceeds 16#FF#.</p>
<p>By a Decode function yielding a Wide_String when the decoding of a sequence results in a code point whose value exceeds 16#FFFF#.</p>
<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} By an Encode function taking a Wide_String as input when an invalid character appears in the input. In particular, the characters whose position is in the range 16#D800# .. 16#DFFF# are invalid because they conflict with UTF-16 surrogate encodings, and the characters whose position is 16#FFFE# or 16#FFFF# are also invalid because they conflict with BOM codes. </p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encoding (Item    : UTF_String;{"\n"}                   Default : Encoding_Scheme := UTF_8){"\n"}   return Encoding_Scheme;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} {"{"}<em>{"AI05-0269-1"}</em>{"}"} Inspects a UTF_String value to determine whether it starts with a BOM for UTF-8, UTF-16BE, or UTF_16LE. If so, returns the scheme corresponding to the BOM; otherwise, returns the value of Default.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Convert (Item          : UTF_String;{"\n"}                  Input_Scheme  : Encoding_Scheme;{"\n"}                  Output_Scheme : Encoding_Scheme;{"\n"}                  Output_BOM    : Boolean := False) return UTF_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item (originally encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in one of these three schemes as specified by Output_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Convert (Item          : UTF_String;{"\n"}                  Input_Scheme  : Encoding_Scheme;{"\n"}                  Output_BOM    : Boolean := False){"\n"}   return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item (originally encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in UTF-16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Convert (Item          : UTF_8_String;{"\n"}                  Output_BOM    : Boolean := False){"\n"}   return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item (originally encoded in UTF-8) encoded in UTF-16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Convert (Item          : UTF_16_Wide_String;{"\n"}                  Output_Scheme : Encoding_Scheme;{"\n"}                  Output_BOM    : Boolean := False) return UTF_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item (originally encoded in UTF-16) encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Output_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Convert (Item          : UTF_16_Wide_String;{"\n"}                  Output_BOM    : Boolean := False) return UTF_8_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item (originally encoded in UTF-16) encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item          : String;{"\n"}                 Output_Scheme : Encoding_Scheme;{"\n"}                 Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} Returns the value of Item encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Output_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF_16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item         : UTF_String;{"\n"}                 Input_Scheme : Encoding_Scheme) return String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_8_String) return String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_16_Wide_String) return String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item          : Wide_String;{"\n"}                 Output_Scheme : Encoding_Scheme;{"\n"}                 Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} Returns the value of Item encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Output_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : Wide_String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : Wide_String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF_16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item         : UTF_String;{"\n"}                 Input_Scheme : Encoding_Scheme) return Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_8_String) return Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_16_Wide_String) return Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item          : Wide_Wide_String;{"\n"}                 Output_Scheme : Encoding_Scheme;{"\n"}                 Output_BOM    : Boolean  := False) return UTF_String;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI05-0262-1"}</em>{"}"} Returns the value of Item encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Output_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : Wide_Wide_String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_8_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Encode (Item       : Wide_Wide_String;{"\n"}                 Output_BOM : Boolean  := False) return UTF_16_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the value of Item encoded in UTF_16.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item         : UTF_String;{"\n"}                 Input_Scheme : Encoding_Scheme) return Wide_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_8_String) return Wide_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-8.</p>
<CodeBlock>
{"{"}{"AI05-0137-2"}{"}"} function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;{"\n"}
</CodeBlock>

<p>Returns the result of decoding Item, which is encoded in UTF-16.</p>

#### Implementation Advice

<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} If an implementation supports other encoding schemes, another similar child of Ada.Strings should be defined. </p>
<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<p><strong></strong>If an implementation supports other string encoding schemes, a child of Ada.Strings similar to UTF_Encoding should be defined.</p></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<p>NOTE 1   {"{"}<em>{"AI05-0137-2"}</em>{"}"} A BOM (Byte-Order Mark, code position 16#FEFF#) can be included in a file or other entity to indicate the encoding; it is skipped when decoding. Typically, only the first line of a file or other entity contains a BOM. When decoding, the Encoding function can be called on the first line to determine the encoding; this encoding will then be used in subsequent calls to Decode to convert all of the lines to an internal format. </p></Admonition>


#### Extensions to Ada 2005

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI05-0137-2"}</em>{"}"} The packages Strings.UTF_Encoding, Strings.UTF_Encoding.Conversions, Strings.UTF_Encoding.Strings, Strings.UTF_Encoding.Wide_Strings, and Strings.UTF_Encoding.Wide_Wide_Strings are new. </p></Admonition>


#### Wording Changes from Ada 2012

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI12-0088-1"}</em>{"}"} <strong>Corrigendum:</strong> Fixed the omission that Convert routines make the same checks on input as Decode routines. </p></Admonition>


## A.4.12  Universal Text Buffers

<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} {"{"}<em>{"AI12-0439-1"}</em>{"}"} A universal text buffer can be used to save and retrieve text of any language-defined string type. The types used to save and retrieve the text can be different. </p>

#### Static Semantics

<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} The text buffer library packages have the following declarations:</p>
<CodeBlock>
{"{"}{"AI12-0340-1"}{"}"} {"{"}{"AI12-0384-2"}{"}"} with Ada.Strings.UTF_Encoding.Wide_Wide_Strings;{"\n"}package Ada.Strings.Text_Buffers{"\n"}   with Pure is{"\n"}
</CodeBlock>

<CodeBlock>
   type Text_Buffer_Count is range 0 .. implementation-defined;{"\n"}
</CodeBlock>

<CodeBlock>
   New_Line_Count : constant Text_Buffer_Count := implementation-defined;{"\n"}
</CodeBlock>

<CodeBlock>
   type Root_Buffer_Type is abstract tagged private{"\n"}      with Default_Initial_Condition ={">"}{"\n"}             Current_Indent (Root_Buffer_Type) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Put ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Item   : in     String) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Wide_Put ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Item   : in     Wide_String) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Wide_Wide_Put ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Item   : in     Wide_Wide_String) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Put_UTF_8 ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Item   : in     UTF_Encoding.UTF_8_String) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Wide_Put_UTF_16 ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Item   : in     UTF_Encoding.UTF_16_Wide_String) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure New_Line (Buffer : in out Root_Buffer_Type) is abstract;{"\n"}
</CodeBlock>

<CodeBlock>
   Standard_Indent : constant Text_Buffer_Count := 3;{"\n"}
</CodeBlock>

<CodeBlock>
   function Current_Indent ({"\n"}      Buffer : Root_Buffer_Type) return Text_Buffer_Count;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Increase_Indent ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Amount : in     Text_Buffer_Count := Standard_Indent){"\n"}      with Post'Class ={">"}{"\n"}         Current_Indent (Buffer) = Current_Indent (Buffer)'Old + Amount;{"\n"}
</CodeBlock>

<CodeBlock>
   procedure Decrease_Indent ({"\n"}      Buffer : in out Root_Buffer_Type;{"\n"}      Amount : in     Text_Buffer_Count := Standard_Indent){"\n"}      with Pre'Class ={">"}{"\n"}              Current_Indent (Buffer) {">"}= Amount{"\n"}                 or else raise Constraint_Error,{"\n"}           Post'Class ={">"}{"\n"}              Current_Indent (Buffer) ={"\n"}                 Current_Indent (Buffer)'Old - Amount;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Strings.Text_Buffers;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI12-0340-1"}{"}"} {"{"}{"AI12-0384-2"}{"}"} package Ada.Strings.Text_Buffers.Unbounded{"\n"}   with Preelaborate, Nonblocking, Global ={">"} null is{"\n"}
</CodeBlock>

<CodeBlock>
   type Buffer_Type is new Root_Buffer_Type with private;{"\n"}
</CodeBlock>

<CodeBlock>
   function Get ({"\n"}      Buffer : in out Buffer_Type){"\n"}      return String{"\n"}      with Post'Class ={">"} {"\n"}         Get'Result'First = 1 and then Current_Indent (Buffer) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
   function Wide_Get ({"\n"}      Buffer : in out Buffer_Type){"\n"}      return Wide_String{"\n"}      with Post'Class ={">"}{"\n"}         Wide_Get'Result'First = 1 and then Current_Indent (Buffer) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
   function Wide_Wide_Get ({"\n"}      Buffer : in out Buffer_Type){"\n"}      return Wide_Wide_String{"\n"}      with Post'Class ={">"}{"\n"}         Wide_Wide_Get'Result'First = 1 {"\n"}            and then Current_Indent (Buffer) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
   function Get_UTF_8 ({"\n"}      Buffer : in out Buffer_Type){"\n"}      return UTF_Encoding.UTF_8_String{"\n"}      with Post'Class ={">"}{"\n"}         Get_UTF_8'Result'First = 1 and then Current_Indent (Buffer) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
   function Wide_Get_UTF_16 ({"\n"}      Buffer : in out Buffer_Type){"\n"}      return UTF_Encoding.UTF_16_Wide_String{"\n"}      with Post'Class ={">"}{"\n"}         Wide_Get_UTF_16'Result'First = 1{"\n"}            and then Current_Indent (Buffer) = 0;{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language, but will include nonabstract{"\n"}       -- overridings of all inherited subprograms that require overriding.{"\n"}end Ada.Strings.Text_Buffers.Unbounded;{"\n"}
</CodeBlock>

<CodeBlock>
{"{"}{"AI12-0340-1"}{"}"} {"{"}{"AI12-0384-2"}{"}"} package Ada.Strings.Text_Buffers.Bounded{"\n"}   with Pure, Nonblocking, Global ={">"} null is{"\n"}
</CodeBlock>

<CodeBlock>
   type Buffer_Type (Max_Characters : Text_Buffer_Count){"\n"}      is new Root_Buffer_Type with private{"\n"}      with Default_Initial_Condition ={">"} not Text_Truncated (Buffer_Type);{"\n"}
</CodeBlock>

<CodeBlock>
   function Text_Truncated (Buffer : in Buffer_Type) return Boolean;{"\n"}
</CodeBlock>

<CodeBlock>
   -- Get, Wide_Get, Wide_Wide_Get, Get_UTF_8, and Wide_Get_UTF_16{"\n"}   -- are declared here just as in the Unbounded child.{"\n"}
</CodeBlock>

<CodeBlock>
private{"\n"}   ... -- not specified by the language, but will include nonabstract{"\n"}       -- overridings of all inherited subprograms that require overriding.{"\n"}end Ada.Strings.Text_Buffers.Bounded;{"\n"}
</CodeBlock>

<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} Character_Count returns the number of characters currently stored in a text buffer.</p>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<p><strong></strong>{"{"}<em>{"AI12-0340-1"}</em>{"}"} This is lower-case "characters". The representation isn't considered, so it is irrelevant what type of character (Character, Wide_Character, or Wide_Wide_Character) was stored. </p></Admonition>

<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} {"{"}<em>{"AI12-0384-2"}</em>{"}"} New_Line stores New_Line_Count characters that represent a new line into a text buffer. Current_Indent returns the current indentation associated with the buffer, with zero meaning there is no indentation in effect; Increase_Indent and Decrease_Indent increase or decrease the indentation associated with the buffer.</p>
<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} {"{"}<em>{"AI12-0384-2"}</em>{"}"} A call to Put, Wide_Put, Wide_Wide_Put, Put_UTF_8, or Wide_Put_UTF_16 stores a sequence of characters into the text buffer, preceded by Current_Indent(Buffer) spaces (Wide_Wide_Characters with position 32) if there is at least one character in Item and it would have been the first character on the current line.</p>
<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} {"{"}<em>{"AI12-0384-2"}</em>{"}"} A call to function Get, Wide_Get, Wide_Wide_Get, Get_UTF_8, or Wide_Get_UTF_16 returns the same sequence of characters as was present in the calls that stored the characters into the buffer, if representable. For a call to Get, if any character in the sequence is not defined in Character, the result is implementation defined. Similarly, for a call to Wide_Get, if any character in the sequence is not defined in Wide_Character, the result is implementation defined. As part of a call on any of the Get functions, the buffer is reset to an empty state, with no stored characters.</p>
<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<p><strong></strong>The value returned by a call to a Text_Buffer Get procedure if any character in the returned sequence is not defined in Character.</p></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<p><strong></strong>The value returned by a call to a Text_Buffer Wide_Get procedure if any character in the returned sequence is not defined in Wide_Character.</p></Admonition>

<p>{"{"}<em>{"AI12-0384-2"}</em>{"}"} In the case of a Buf of type Text_Buffers.Bounded.Buffer_Type, Text_Truncated (Buf) returns True if the various Put procedures together have attempted to store more than Buf.Max_Characters into Buf. If this function returns True, then the various Get functions return a representation of only the first Buf.Max_Characters characters that were stored in Buf.</p>

#### Implementation Advice

<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} Bounded buffer objects should be implemented without dynamic allocation.</p>
<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<p><strong></strong>Bounded buffer objects should be implemented without dynamic allocation.</p></Admonition>


#### Extensions to Ada 2012

<Admonition type="aarm" aarm="note" title="Note: ">
<p>{"{"}<em>{"AI12-0340-1"}</em>{"}"} {"{"}<em>{"AI12-0384-2"}</em>{"}"} The packages Strings.Text_Buffers, Strings.Text_Buffers.Unbounded, and Strings.Text_Buffers.Bounded are new. </p></Admonition>

