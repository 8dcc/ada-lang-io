---
sidebar_position:  108
---

# 13.4 Enumeration Representation Clauses

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[An <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> specifies the internal codes for enumeration literals.] <br /></p>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>enumeration_representation_clause</code><a id="S0350"></a><code> ::= </code><br />    <strong>for</strong> <em>first_subtype_</em><code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> <strong>use</strong> <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code>;<br />

</CodeBlock>
<MarginText>3</MarginText>

<CodeBlock>
<code>enumeration_aggregate</code><a id="S0351"></a><code> ::= </code><code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code><br />

</CodeBlock>

#### Name Resolution Rules

<MarginText>4</MarginText>
<p>The <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code> shall be written as a one-dimensional <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code>, for which the index subtype is the unconstrained subtype of the enumeration type, and each component expression is expected to be of any integer type. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The &ldquo;full coverage rules&rdquo; for <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s applies. An <strong>others</strong> is not allowed &mdash; there is no applicable index constraint in this context. <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>5</MarginText>
<p>The <em>first_subtype_</em><code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> of an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> shall denote an enumeration subtype. <br /></p>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>As for all type-related representation items, the <code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> is required to denote a first subtype. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00287-01"]} />
<p>Each component of the <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code> shall be given by an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> rather than a {"<"}{">"}. The <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s given in the <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code> shall be static, and shall specify distinct integer codes for each value of the enumeration type; the associated integer codes shall satisfy the predefined ordering relation of the type. <br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Each value of the enumeration type has to be given an internal code, even if the first subtype of the enumeration type is constrained to only a subrange (this is only possible if the enumeration type is a derived type). This &ldquo;full coverage&rdquo; requirement is important because one may refer to Enum'Base'First and Enum'Base'Last, which need to have defined representations. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>7</MarginText>
<p>An <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> specifies the <em>coding</em> aspect of representation. The coding consists of the <em>internal code</em> for each enumeration literal, that is, the integral value used internally to represent each literal.<br /></p>

<AnnotatedOnly>
<MarginText>7.a/3</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Aspect Description for </strong><strong>Coding: </strong>Internal representation of enumeration literals. Specified by an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>, not by an <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>.<br /></Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>8</MarginText>
<p>For nonboolean enumeration types, if the coding is not specified for the type, then for each value of the type, the internal code shall be equal to its position number. <br /></p>

<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This default representation is already used by all known Ada compilers for nonboolean enumeration types. Therefore, we make it a requirement so users can depend on it, rather than feeling obliged to supply for every enumeration type an enumeration representation clause that is equivalent to this default rule. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For boolean types, it is relatively common to use all ones for True, and all zeros for False, since some hardware supports that directly. Of course, for a one-bit Boolean object (like in a packed array), False is presumably zero and True is presumably one (choosing the reverse would be extremely unfriendly!). <br /></Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>9</MarginText>
<p>The recommended level of support for <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s is: <br /></p>

<MarginText>10/5</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<ul>
<li>An implementation should support at least the internal codes in the range System.Min_Int .. System.Max_Int. An implementation is not required to  support <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s for boolean types. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The implementation may support numbers outside the above range, such as numbers greater than System.Max_Int. See AI83-00564. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The benefits of specifying the internal coding of a boolean type do not outweigh the implementation costs. Consider, for example, the implementation of the logical operators on a packed array of booleans with strange internal codes. It's implementable, but not worth it. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.c/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>The recommended level of support for <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s should be followed.<br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>10.1/5</MarginText>
<MarginInfo items={["AI12-0237-1"]} />
<p>For every discrete subtype S, the following attributes are defined: <br /></p>

<MarginText>10.2/5</MarginText>
<dt><br/>S'Enum_Rep</dt>
<MarginInfo items={["AI12-0237-1"]} />
<dl>
<dd>S'Enum_Rep denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>10.3/5</MarginText>
<CodeBlock language="ada">
function S'Enum_Rep (Arg : S'Base) return universal_integer{"\n"}

</CodeBlock>
<MarginText>10.4/5</MarginText>
<dl>
<dd>This function returns the representation value of the value of Arg, as a value of type <em>universal_integer</em>. The <em>representation value</em> is the internal code specified in an enumeration representation clause, if any, for the type corresponding to the value of Arg, and otherwise is the position number of the value.<br /></dd>
<MarginText>10.5/5</MarginText>
<dt><br/>S'Enum_Val</dt>
<MarginInfo items={["AI12-0237-1"]} />
<dd>S'Enum_Val denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>10.6/5</MarginText>
<CodeBlock language="ada">
function S'Enum_Val (Arg : universal_integer) return S'Base{"\n"}

</CodeBlock>
<MarginText>10.7/5</MarginText>
<dl>
<dd>This function returns a value of the type of S whose representation value equals the value of Arg. For the evaluation of a call on S'Enum_Val, if there is no value in the base range of its type with the given representation value, Constraint_Error is raised.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>10.d/5</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We define these on all discrete types so that they can be used inside of a generic unit on a subtype of a generic formal discrete type. They're not useful on integer types (they have the same effect as S'Pos and S'Val). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11/5</MarginText>
<MarginInfo items={["AI95-00137-01", "AI05-0299-1", "AI12-0237-1", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   {"{"}<em>8652/0009</em>{"}"} Attribute Enum_Rep  can  be used to query the internal codes used for an enumeration type; attribute Enum_Val can  be used to convert from an internal code to an enumeration value. The other attributes of the type, such as Succ, Pred, and Pos, are unaffected by an  <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. For example, Pos always returns the position number, <em>not</em> an  internal integer code that was  specified in an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Suppose the enumeration type in question is derived: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b</MarginText>
<CodeBlock language="ada">
type T1 is (Red, Green, Blue);{"\n"}subtype S1 is T1 range Red .. Green;{"\n"}type S2 is new S1;{"\n"}for S2 use (Red ={">"} 10, Green ={">"} 20, Blue ={">"} 30);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.c/1</MarginText>
<MarginInfo items={["AI95-00137-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0009</em>{"}"} The <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> has to specify values for all enumerals, even ones that are not in S2 (such as Blue). The Base attribute can be used to get at these values. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.d</MarginText>
<CodeBlock language="ada">
for I in S2'Base loop{"\n"}    ... -- When I equals Blue, the internal code is 30.{"\n"}end loop;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.e</MarginText>
<Admonition type="aarm" aarm="note">
We considered allowing or requiring &ldquo;<strong>for</strong> S2'Base <strong>use</strong> ...&rdquo; in cases like this, but it didn't seem worth the trouble. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>12/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
<p><em>Examples  of  enumeration representation clauses :</em> <br /></p>

<MarginText>13</MarginText>
<CodeBlock language="ada">
type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);{"\n"}
<MarginText>14</MarginText>
for Mix_Code use{"\n"}   (ADD ={">"} 1, SUB ={">"} 2, MUL ={">"} 3, LDA ={">"} 8, STA ={">"} 24, STZ ={">"}33);{"\n"}
<MarginText>15/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
-- See <a href="../AA-3/AA-3.5#Subclause_3.5.2">3.5.2</a>.{"\n"}for Roman_Digit use ('I' ={">"} 1,{"\n"}                     'V' ={">"} 5,{"\n"}                     'X' ={">"} 10,{"\n"}                     'L' ={">"} 50,{"\n"}                     'C' ={">"} 100,{"\n"}                     'D' ={">"} 500,{"\n"}                     'M' ={">"} 1000);{"\n"}
<MarginText>16/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
-- For an example of the use of attribute Enum_Rep, see <a href="../AA-4/AA-4.2#Subclause_4.2.1">4.2.1</a>.{"\n"}

</CodeBlock>

#### Extensions to Ada 83

<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="note">
As in other similar contexts, Ada 95 allows expressions of any integer type, not just expressions of type <em>universal_integer</em>, for the component expressions in the <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code>. The preference rules for the predefined operators of <em>root_integer</em> eliminate any ambiguity.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b</MarginText>
<Admonition type="aarm" aarm="note">
For portability, we now require that the default coding for an enumeration type be the &ldquo;obvious&rdquo; coding using position numbers. This is satisfied by all known implementations. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 95

<AnnotatedOnly>
<MarginText>16.c/2</MarginText>
<MarginInfo items={["AI95-00137-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0009</em>{"}"} <strong>Corrigendum:</strong> Updated to reflect that we no longer have something called <code>representation_clause</code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.d/2</MarginText>
<MarginInfo items={["AI95-00287-01"]} />
<Admonition type="aarm" aarm="note">
Added wording to prevent the use of {"<"}{">"} in a <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. ({"<"}{">"} is newly added to <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code>s.) <br /></Admonition>
</AnnotatedOnly>


#### Extensions to Ada 2012

<AnnotatedOnly>
<MarginText>16.e/5</MarginText>
<MarginInfo items={["AI12-0237-1"]} />
<Admonition type="aarm" aarm="note">
Attributes Enum_Rep and Enum_Val are new. <br /></Admonition>
</AnnotatedOnly>

