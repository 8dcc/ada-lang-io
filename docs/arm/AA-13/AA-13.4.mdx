---
sidebar_position:  106
---

# 13.4 Enumeration Representation Clauses

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

<p>[An <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> specifies the internal codes for enumeration literals.] <br /></p>


#### Syntax

<p><code>enumeration_representation_clause</code><a id="S0350"></a><code> ::= </code><br />    <strong>for</strong> <em>first_subtype_</em><code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> <strong>use</strong> <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code>;<br /></p>

<p><code>enumeration_aggregate</code><a id="S0351"></a><code> ::= </code><code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code><br /></p>


#### Name Resolution Rules

<p>The <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code> shall be written as a one-dimensional <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code>, for which the index subtype is the unconstrained subtype of the enumeration type, and each component expression is expected to be of any integer type. <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The "full coverage rules" for <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s applies. An <strong>others</strong> is not allowed - there is no applicable index constraint in this context. <br /></Admonition>


#### Legality Rules

<p>The <em>first_subtype_</em><code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> of an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> shall denote an enumeration subtype. <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>As for all type-related representation items, the <code><a href="../AA-13/AA-13.1#S0345">local_name</a></code> is required to denote a first subtype. <br /></Admonition>

<p>{"{"}<em>{"AI95-00287-01"}</em>{"}"} <br />Each component of the <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code> shall be given by an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> rather than a {"<"}{">"}. The <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s given in the <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code> shall be static, and shall specify distinct integer codes for each value of the enumeration type; the associated integer codes shall satisfy the predefined ordering relation of the type. <br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>Each value of the enumeration type has to be given an internal code, even if the first subtype of the enumeration type is constrained to only a subrange (this is only possible if the enumeration type is a derived type). This "full coverage" requirement is important because one may refer to Enum'Base'First and Enum'Base'Last, which need to have defined representations. <br /></Admonition>


#### Static Semantics

<p>An <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> specifies the <em>coding</em> aspect of representation. The coding consists of the <em>internal code</em> for each enumeration literal, that is, the integral value used internally to represent each literal.<br /></p>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>Aspect Description for </strong><strong>Coding: </strong>Internal representation of enumeration literals. Specified by an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>, not by an <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>.<br /></Admonition>


#### Implementation Requirements

<p>For nonboolean enumeration types, if the coding is not specified for the type, then for each value of the type, the internal code shall be equal to its position number. <br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>This default representation is already used by all known Ada compilers for nonboolean enumeration types. Therefore, we make it a requirement so users can depend on it, rather than feeling obliged to supply for every enumeration type an enumeration representation clause that is equivalent to this default rule. <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>For boolean types, it is relatively common to use all ones for True, and all zeros for False, since some hardware supports that directly. Of course, for a one-bit Boolean object (like in a packed array), False is presumably zero and True is presumably one (choosing the reverse would be extremely unfriendly!). <br /></Admonition>


#### Implementation Advice

<p>The recommended level of support for <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s is: <br /></p>

<ul>
<li>{"{"}<em>{"AI12-0444-1"}</em>{"}"} <br />An implementation should support at least the internal codes in the range System.Min_Int .. System.Max_Int. An implementation is not required to support <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s for boolean types. <br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The implementation may support numbers outside the above range, such as numbers greater than System.Max_Int. See AI83-00564. <br /></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>The benefits of specifying the internal coding of a boolean type do not outweigh the implementation costs. Consider, for example, the implementation of the logical operators on a packed array of booleans with strange internal codes. It's implementable, but not worth it. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<strong></strong>The recommended level of support for <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>s should be followed.<br /></Admonition>


#### Static Semantics

<p>{"{"}<em>{"AI12-0237-1"}</em>{"}"} <br />For every discrete subtype S, the following attributes are defined: <br /></p>

<dt><br/>S'Enum_Rep</dt>
<dl>
<dd>{"{"}<em>{"AI12-0237-1"}</em>{"}"} <br />S'Enum_Rep denotes a function with the following specification: <br /></dd>
</dl>
<CodeBlock>
function S'Enum_Rep (Arg : S'Base) return universal_integer{"\n"}

</CodeBlock>
<dl>
<dd>This function returns the representation value of the value of Arg, as a value of type <em>universal_integer</em>. The <em>representation value</em> is the internal code specified in an enumeration representation clause, if any, for the type corresponding to the value of Arg, and otherwise is the position number of the value.<br /></dd>
<dt><br/>S'Enum_Val</dt>
<dd>{"{"}<em>{"AI12-0237-1"}</em>{"}"} <br />S'Enum_Val denotes a function with the following specification: <br /></dd>
</dl>
<CodeBlock>
function S'Enum_Val (Arg : universal_integer) return S'Base{"\n"}

</CodeBlock>
<dl>
<dd>This function returns a value of the type of S whose representation value equals the value of Arg. For the evaluation of a call on S'Enum_Val, if there is no value in the base range of its type with the given representation value, Constraint_Error is raised.<br /></dd>
</dl>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>We define these on all discrete types so that they can be used inside of a generic unit on a subtype of a generic formal discrete type. They're not useful on integer types (they have the same effect as S'Pos and S'Val). <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE   {"{"}<em>8652/0009</em>{"}"} {"{"}<em>{"AI95-00137-01"}</em>{"}"} {"{"}<em>{"AI05-0299-1"}</em>{"}"} {"{"}<em>{"AI12-0237-1"}</em>{"}"} {"{"}<em>{"AI12-0442-1"}</em>{"}"} <br />Attribute Enum_Rep can be used to query the internal codes used for an enumeration type; attribute Enum_Val can be used to convert from an internal code to an enumeration value. The other attributes of the type, such as Succ, Pred, and Pos, are unaffected by an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. For example, Pos always returns the position number, <em>not</em> an internal integer code that was specified in an <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Suppose the enumeration type in question is derived: <br /></Admonition>

<CodeBlock>
type T1 is (Red, Green, Blue);{"\n"}subtype S1 is T1 range Red .. Green;{"\n"}type S2 is new S1;{"\n"}for S2 use (Red ={">"} 10, Green ={">"} 20, Blue ={">"} 30);{"\n"}

</CodeBlock>
<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>8652/0009</em>{"}"} {"{"}<em>{"AI95-00137-01"}</em>{"}"} <br />The <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code> has to specify values for all enumerals, even ones that are not in S2 (such as Blue). The Base attribute can be used to get at these values. For example: <br /></Admonition>

<CodeBlock>
for I in S2'Base loop{"\n"}    ... -- When I equals Blue, the internal code is 30.{"\n"}end loop;{"\n"}

</CodeBlock>
<Admonition type="aarm" aarm="note" title="Note: ">
We considered allowing or requiring "<strong>for</strong> S2'Base <strong>use</strong> ..." in cases like this, but it didn't seem worth the trouble. <br /></Admonition>


#### Examples

<p>{"{"}<em>{"AI12-0312-1"}</em>{"}"} <em><br />Examples of enumeration representation clauses:</em> <br /></p>

<CodeBlock>
type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);{"\n"}
for Mix_Code use{"\n"}   (ADD ={">"} 1, SUB ={">"} 2, MUL ={">"} 3, LDA ={">"} 8, STA ={">"} 24, STZ ={">"}33);{"\n"}
--  {"{"}{"AI12-0312-1"}{"}"}{"\n"} -- See 3.5.2.{"\n"}for Roman_Digit use ('I' ={">"} 1,{"\n"}                     'V' ={">"} 5,{"\n"}                     'X' ={">"} 10,{"\n"}                     'L' ={">"} 50,{"\n"}                     'C' ={">"} 100,{"\n"}                     'D' ={">"} 500,{"\n"}                     'M' ={">"} 1000);{"\n"}
--  {"{"}{"AI12-0312-1"}{"}"}{"\n"} -- For an example of the use of attribute Enum_Rep, see 4.2.1.{"\n"}

</CodeBlock>

#### Extensions to Ada 83

<Admonition type="aarm" aarm="note" title="Note: ">
As in other similar contexts, Ada 95 allows expressions of any integer type, not just expressions of type <em>universal_integer</em>, for the component expressions in the <code><a href="../AA-13/AA-13.4#S0351">enumeration_aggregate</a></code>. The preference rules for the predefined operators of <em>root_integer</em> eliminate any ambiguity.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
For portability, we now require that the default coding for an enumeration type be the "obvious" coding using position numbers. This is satisfied by all known implementations. <br /></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>8652/0009</em>{"}"} {"{"}<em>{"AI95-00137-01"}</em>{"}"} <strong><br />Corrigendum:</strong> Updated to reflect that we no longer have something called <code>representation_clause</code>.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00287-01"}</em>{"}"} <br />Added wording to prevent the use of {"<"}{">"} in a <code><a href="../AA-13/AA-13.4#S0350">enumeration_representation_clause</a></code>. ({"<"}{">"} is newly added to <code><a href="../AA-4/AA-4.3#S0113">array_aggregate</a></code>s.) <br /></Admonition>


#### Extensions to Ada 2012

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0237-1"}</em>{"}"} <br />Attributes Enum_Rep and Enum_Val are new. <br /></Admonition>

