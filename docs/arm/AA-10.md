---
sidebar_position:  11
---

# 10 Program Structure and Compilation Issues

:::warning
We're still working on the Reference manual output.  Internal links are broken,
as are a bunch of other things.
See the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::
[The overall structure of programs and the facilities for separate compilation are described in this section. A program is a set of partitions, each of which may execute in a separate address space, possibly on a separate computer. 

Glossary entry: A program is a set of partitions, each of which may execute in a separate address space, possibly on a separate computer. A partition consists of a set of library units.

Glossary entry: A partition is a part of a program. Each partition consists of a set of library units. Each partition may run in a separate address space, possibly on a separate computer. A program may contain just one partition. A distributed program typically contains multiple partitions, which can execute concurrently.

Version=[5],Kind=(AddedNormal),Group=[C],Term=[program], Def=[a set of partitions, each of which can execute in a separate address space, possibly on a separate computer] Version=[5],Kind=(AddedNormal),Group=[C],Term=[partition], Def=[a part of a program, which consists of a set of interdependent library units], Note1=[Each partition can run in a separate address space, possibly on a separate computer. A program can contain just one partition, or it can be distributed across multiple partitions, which can execute concurrently.]

As explained below, a partition is constructed from library units. Syntactically, the declaration of a library unit is a [library_item](S0216), as is the body of a library unit. An implementation may support a concept of a program library (or simply, a "library"), which contains [library_item](S0216)s and their subunits. Library units may be organized into a hierarchy of children, grandchildren, and so on.]

This section has two clauses: 10.1, "Separate Compilation" discusses compile-time issues related to separate compilation. 10.2, "Program Execution" discusses issues related to what is traditionally known as "link time" and "run time" - building and executing partitions.


#### Language Design Principles

We should avoid specifying details that are outside the domain of the language itself. The standard is intended (at least in part) to promote portability of Ada programs at the source level. It is not intended to standardize extra-language issues such as how one invokes the compiler (or other tools), how one's source is represented and organized, version management, the format of error messages, etc.

The rules of the language should be enforced even in the presence of separate compilation. Using separate compilation should not make a program less safe.

It should be possible to determine the legality of a compilation unit by looking only at the compilation unit itself and the compilation units upon which it depends semantically. As an example, it should be possible to analyze the legality of two compilation units in parallel if they do not depend semantically upon each other.

On the other hand, it may be necessary to look outside that set in order to generate code - this is generally true for generic instantiation and inlining, for example. Also on the other hand, it is generally necessary to look outside that set in order to check Post-Compilation Rules.

See also the "generic contract model" Language Design Principle of 12.3, "Generic Instantiation". 


#### Wording Changes from Ada 83

The section organization mentioned above is different from that of RM83. 


## 10.1  Separate Compilation

[ A program unit is either a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal. Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units. Version=[5],Kind=(AddedNormal),Group=[C],Term=[program unit], Def=[a language construct that is a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal], Note1=[Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units.]

The text of a program can be submitted to the compiler in one or more [compilation](S0214)s. Each [compilation](S0214) is a succession of [compilation_unit](S0215)s. A [compilation_unit](S0215) contains either the declaration, the body, or a renaming of a program unit.] Version=[5],Kind=(AddedNormal),Group=[C],Term=[compilation unit], Def=[a program unit that is separately compiled], Note1=[A [compilation_unit](S0215) contains either the declaration, the body, or a renaming of a program unit.] The representation for a [compilation](S0214) is implementation-defined. 

Implementation defined: The representation for a [compilation](S0214).

Ramification: Some implementations might choose to make a [compilation](S0214) be a source (text) file. Others might allow multiple source files to be automatically concatenated to form a single [compilation](S0214). Others still may represent the source in a nontextual form such as a parse tree. Note that the RM95 does not even define the concept of a source file.

Note that a protected subprogram is a subprogram, and therefore a program unit. An instance of a generic unit is a program unit.

A protected entry is a program unit, but protected entries cannot be separately compiled. 

A library unit is a separately compiled program unit, and is always a package, subprogram, or generic unit. Library units may have other (logically nested) library units as children, and may have other program units physically nested within them. A root library unit, together with its children and grandchildren and so on, form a subsystem. Version=[5],Kind=(AddedNormal),Group=[C],Term=[library unit], Def=[a separately compiled program unit, which is a package, a subprogram, or a generic unit], Note1=[Library units can have other (logically nested) library units as children, and can have other program units physically nested within them. A root library unit, together with its children and grandchildren and so on, form a subsystem.] 


#### Implementation Permissions

An implementation may impose implementation-defined restrictions on [compilation](S0214)s that contain multiple [compilation_unit](S0215)s. 

Implementation defined: Any restrictions on [compilation](S0214)s that contain multiple [compilation_unit](S0215)s.

Discussion: For example, an implementation might disallow a [compilation](S0214) that contains two versions of the same compilation unit, or that contains the declarations for library packages P1 and P2, where P1 precedes P2 in the [compilation](S0214) but P1 has a [with_clause](S0223) that mentions P2. 


#### Wording Changes from Ada 83

The interactions between language issues and environmental issues are left open in Ada 95. The environment concept is new. In Ada 83, the concept of the program library, for example, appeared to be quite concrete, although the rules had no force, since implementations could get around them simply by defining various mappings from the concept of an Ada program library to whatever data structures were actually stored in support of separate compilation. Indeed, implementations were encouraged to do so.

In RM83, it was unclear which was the official definition of "program unit". Definitions appeared in RM83-5, 6, 7, and 9, but not 12. Placing it here seems logical, since a program unit is sort of a potential compilation unit. 


### 10.1.1  Compilation Units - Library Units

[A [library_item](S0216) is a compilation unit that is the declaration, body, or renaming of a library unit. Each library unit (except Standard) has a parent unit, which is a library package or generic library package.] A library unit is a child of its parent unit. The root library units are the children of the predefined library package Standard. 

Ramification: Standard is a library unit. 


#### Syntax

compilation ::= {[compilation_unit](S0215)}

compilation_unit ::= 
    [context_clause](S0221) [library_item](S0216)
  | [context_clause](S0221) [subunit](S0229)

library_item ::= [private] [library_unit_declaration](S0217)
  | [library_unit_body](S0219)
  | [private] [library_unit_renaming_declaration](S0218)

library_unit_declaration ::= 
     [subprogram_declaration](S0141)	| [package_declaration](S0161)
   | [generic_declaration](S0236)	| [generic_instantiation](S0241)

library_unit_renaming_declaration ::= 
   [package_renaming_declaration](S0172)
 | [generic_renaming_declaration](S0174)
 | [subprogram_renaming_declaration](S0173)

library_unit_body ::= [subprogram_body](S0154) | [package_body](S0163)

parent_unit_name ::= [name](S0084)

A library unit is a program unit that is declared by a [library_item](S0216). When a program unit is a library unit, the prefix "library" is used to refer to it (or "generic library" if generic), as well as to its declaration and body, as in "library procedure", "library [package_body](S0163)", or "generic library package". The term compilation unit is used to refer to a [compilation_unit](S0215). When the meaning is clear from context, the term is also used to refer to the [library_item](S0216) of a [compilation_unit](S0215) or to the [proper_body](S0083) of a [subunit](S0229) [(that is, the [compilation_unit](S0215) without the [context_clause](S0221) and the separate ([parent_unit_name](S0220)))]. 

Discussion: In this example: 

```ada
with Ada.Text_IO;
package P is
    ...
end P;

```

the term "compilation unit" can refer to this text: "with Ada.Text_IO; package P is ... end P;" or to this text: "package P is ... end P;". We use this shorthand because it corresponds to common usage.

We like to use the word "unit" for declaration-plus-body things, and "item" for declaration or body separately (as in [declarative_item](S0080)). The terms "[compilation_unit](S0215)", "compilation unit", and "[subunit](S0229)" are exceptions to this rule. We considered changing "[compilation_unit](S0215)", "compilation unit" to "compilation_item", "compilation item", respectively, but we decided not to. 

The parent declaration of a [library_item](S0216) (and of the library unit) is the declaration denoted by the [parent_unit_name](S0220), if any, of the [defining_program_unit_name](S0146) of the [library_item](S0216). If there is no [parent_unit_name](S0220), the parent declaration is the declaration of Standard, the [library_item](S0216) is a root [library_item](S0216), and the library unit (renaming) is a root library unit (renaming). The declaration and body of Standard itself have no parent declaration. The parent unit of a [library_item](S0216) or library unit is the library unit declared by its parent declaration. 

Discussion: The declaration and body of Standard are presumed to exist from the beginning of time, as it were. There is no way to actually write them, since there is no syntactic way to indicate lack of a parent. An attempt to compile a package Standard would result in Standard.Standard. 

Reason: Library units (other than Standard) have "parent declarations" and "parent units". Subunits have "parent bodies". We didn't bother to define the other possibilities: parent body of a library unit, parent declaration of a subunit, parent unit of a subunit. These are not needed, and might get in the way of a correct definition of "child". 

[The children of a library unit occur immediately within the declarative region of the declaration of the library unit.] The ancestors of a library unit are itself, its parent, its parent's parent, and so on. [(Standard is an ancestor of every library unit.)] The descendant relation is the inverse of the ancestor relation. 

Reason: These definitions are worded carefully to avoid defining subunits as children. Only library units can be children.

We use the unadorned term "ancestors" here to concisely define both "ancestor unit" and "ancestor declaration". 

A [library_unit_declaration](S0217) or a [library_unit_renaming_declaration](S0218) is private if the declaration is immediately preceded by the reserved word private; it is otherwise public. A library unit is private or public according to its declaration. The public descendants of a library unit are the library unit itself, and the public descendants of its public children. Its other descendants are private descendants. 

Discussion: The first concept defined here is that a [library_item](S0216) is either public or private (not in relation to anything else - it's just a property of the library unit). The second concept is that a [library_item](S0216) is a public descendant or private descendant of a given ancestor. A given [library_item](S0216) can be a public descendant of one of its ancestors, but a private descendant of some other ancestor.

A subprogram declared by a [subprogram_body](S0154) (as opposed to a [subprogram_declaration](S0141)) is always public, since the syntax rules disallow the reserved word private on a body.

Note that a private library unit is a public descendant of itself, but a private descendant of its parent. This is because it is visible outside itself - its privateness means that it is not visible outside its parent.

Private children of Standard are legal, and follow the normal rules. It is intended that implementations might have some method for taking an existing environment, and treating it as a package to be "imported" into another environment, treating children of Standard in the imported environment as children of the imported package. 

Ramification: Suppose we have a public library unit A, a private library unit A.B, and a public library unit A.B.C. A.B.C is a public descendant of itself and of A.B, but a private descendant of A; since A.B is private to A, we don't allow A.B.C to escape outside A either. This is similar to the situation that would occur with physical nesting, like this: 

```ada
package A is
private
    package B is
        package C is
        end C;
    private
    end B;
end A;

```

Here, A.B.C is visible outside itself and outside A.B, but not outside A. (Note that this example is intended to illustrate the visibility of program units from the outside; the visibility within child units is not quite identical to that of physically nested units, since child units are nested after their parent's declaration.) 


#### Legality Rules

The parent unit of a [library_item](S0216) shall be a [library] package or generic [library] package.

If a [defining_program_unit_name](S0146) of a given declaration or body has a [parent_unit_name](S0220), then the given declaration or body shall be a [library_item](S0216). The body of a program unit shall be a [library_item](S0216) if and only if the declaration of the program unit is a [library_item](S0216). In a [library_unit_renaming_declaration](S0218), the [(old)] [name](S0084) shall denote a [library_item](S0216). 

Discussion: We could have allowed nested program units to be children of other program units; their semantics would make sense. We disallow them to keep things simpler and because they wouldn't be particularly useful. 

A [parent_unit_name](S0220) [(which can be used within a [defining_program_unit_name](S0146) of a [library_item](S0216) and in the separate clause of a [subunit](S0229))], and each of its [prefix](S0086)es, shall not denote a [renaming_declaration](S0169). [On the other hand, a name that denotes a [library_unit_renaming_declaration](S0218) is allowed in a [with_clause](S0223) and other places where the name of a library unit is allowed.]

If a library package is an instance of a generic package, then every child of the library package shall either be itself an instance or be a renaming of a library unit. 

Discussion: A child of an instance of a given generic unit will often be an instance of a (generic) child of the given generic unit. This is not required, however. 

Reason: Instances are forbidden from having noninstance children for two reasons: 

a)We want all source code that can depend on information from the private part of a library unit to be inside the "subsystem" rooted at the library unit. If an instance of a generic unit were allowed to have a noninstance as a child, the source code of that child might depend on information from the private part of the generic unit, even though it is outside the subsystem rooted at the generic unit.

b)Disallowing noninstance children simplifies the description of the semantics of children of generic packages. 

A child of a generic library package shall either be itself a generic unit or be a renaming of some other child of the same generic unit. The renaming of a child of a generic package shall occur only within the declarative region of the generic package.

A child of a parent generic package shall be instantiated or renamed only within the declarative region of the parent generic.

For each declaration or renaming of a generic unit as a child of some parent generic package, there is a corresponding declaration  nested immediately within each instance of the parent. [This declaration is visible only within the scope of a [with_clause](S0223) that mentions the child generic unit.]

Implementation Note: Within the child, like anything nested in a generic unit, one can make up-level references to the current instance of its parent, and thereby gain access to the formal parameters of the parent, to the types declared in the parent, etc. This "nesting" model applies even within the [generic_formal_part](S0239) of the child, as it does for a generic child of a nongeneric unit. 

Ramification: Suppose P is a generic library package, and P.C is a generic child of P. P.C can be instantiated inside the declarative region of P. Outside P, P.C can be mentioned only in a [with_clause](S0223). Conceptually, an instance I of P is a package that has a nested generic unit called I.C. Mentioning P.C in a [with_clause](S0223) allows I.C to be instantiated. I need not be a library unit, and the instantiation of I.C need not be a library unit. If I is a library unit, and an instance of I.C is a child of I, then this instance has to be called something other than C.

A library subprogram shall not override a primitive subprogram. 

Reason: This prevents certain obscure anomalies. For example, if a library subprogram were to override a subprogram declared in its parent package, then in a compilation unit that depends indirectly on the library subprogram, the library subprogram could hide the overridden operation from all visibility, but the library subprogram itself would not be visible.

Note that even without this rule, such subprograms would be illegal for tagged types, because of the freezing rules. 

The defining name of a function that is a compilation unit shall not be an [operator_symbol](S0147). 

Reason: Since overloading is not permitted among compilation units, it seems unlikely that it would be useful to define one as an operator. Note that a subunit could be renamed within its parent to be an operator. 


#### Static Semantics

A [subprogram_renaming_declaration](S0173) that is a [library_unit_renaming_declaration](S0218) is a renaming-as-declaration, not a renaming-as-body.

[There are two kinds of dependences among compilation units:] 

[The semantic dependences (see below) are the ones needed to check the compile-time rules across compilation unit boundaries; a compilation unit depends semantically on the other compilation units needed to determine its legality. The visibility rules are based on the semantic dependences.

The elaboration dependences (see 10.2) determine the order of elaboration of [library_item](S0216)s.] 

Discussion: Don't confuse these kinds of dependences with the run-time dependences among tasks and masters defined in 9.3, "Task Dependence - Termination of Tasks". 

A [library_item](S0216) depends semantically upon its parent declaration. A subunit depends semantically upon its parent body. A [library_unit_body](S0219) depends semantically upon the corresponding [library_unit_declaration](S0217), if any. A compilation unit depends semantically upon each [library_item](S0216) mentioned in a [with_clause](S0223) of the compilation unit. In addition, if a given compilation unit contains an [attribute_reference](S0093) of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. The semantic dependence relationship is transitive.

Discussion: The "if any" in the third sentence is necessary because library subprograms are not required to have a [subprogram_declaration](S0141). 

To be honest: If a given compilation unit contains a [choice_parameter_specification](S0233), then the given compilation unit depends semantically upon the declaration of Ada.Exceptions.

If a given compilation unit contains a [pragma](S0016) with an argument of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. 

Discussion: For example, a compilation unit containing X'Address depends semantically upon the declaration of package System.

For the Address attribute, this fixes a hole in Ada 83. Note that in almost all cases, the dependence will need to exist due to [with_clause](S0223)s, even without this rule. Hence, the rule has very little effect on programmers.

Note that the semantic dependence does not have the same effect as a [with_clause](S0223); in order to denote a declaration in one of those packages, a [with_clause](S0223) will generally be needed.

Note that no special rule is needed for an [attribute_definition_clause](S0265), since an expression after use will require semantic dependence upon the compilation unit containing the [type_declaration](S0020) of interest.

NOTE 1   A simple program may consist of a single compilation unit. A [compilation](S0214) need not have any compilation units; for example, its text can consist of [pragma](S0016)s. 

Ramification: Such [pragma](S0016)s cannot have any arguments that are [name](S0084)s, by a previous rule of this subclause. A [compilation](S0214) can even be entirely empty, which is probably not useful.

Some interesting properties of the three kinds of dependence: The elaboration dependences also include the semantic dependences, except that subunits are taken together with their parents. The semantic dependences partly determine the order in which the compilation units appear in the environment at compile time. At run time, the order is partly determined by the elaboration dependences.

The model whereby a child is inside its parent's declarative region, after the parent's declaration, as explained in 8.1, has the following ramifications: 

The restrictions on "early" use of a private type (RM83-7.4.1(4)) or a deferred constant (RM83-7.4.3(2)) do not apply to uses in child units, because they follow the full declaration.

A library subprogram is never primitive, even if its profile includes a type declared immediately within the parent's [package_specification](S0162), because the child is not declared immediately within the same [package_specification](S0162) as the type (so it doesn't declare a new primitive subprogram), and because the child is forbidden from overriding an old primitive subprogram. It is immediately within the same declarative region, but not the same [package_specification](S0162). Thus, for a tagged type, it is not possible to call a child subprogram in a dispatching manner. (This is also forbidden by the freezing rules.) Similarly, it is not possible for the user to declare primitive subprograms of the types declared in the declaration of Standard, such as Integer (even if the rules were changed to allow a library unit whose name is an operator symbol).

When the parent unit is "used" the simple names of the with'd child units are directly visible (see 8.4, "Use Clauses").

When a parent body with's its own child, the defining name of the child is directly visible, and the parent body is not allowed to include a declaration of a homograph of the child unit immediately within the [declarative_part](S0079) of the body (RM83-8.3(17)). 

Note that "declaration of a library unit" is different from "[library_unit_declaration](S0217)" - the former includes [subprogram_body](S0154). Also, we sometimes really mean "declaration of a view of a library unit", which includes [library_unit_renaming_declaration](S0218)s.

The visibility rules generally imply that the renamed view of a [library_unit_renaming_declaration](S0218) has to be mentioned in a [with_clause](S0223) of the [library_unit_renaming_declaration](S0218). 

To be honest: The real rule is that the renamed library unit has to be visible in the [library_unit_renaming_declaration](S0218). 

Reason: In most cases, "has to be visible" means there has to be a [with_clause](S0223). However, it is possible in obscure cases to avoid the need for a [with_clause](S0223); in particular, a compilation unit such as "package P.Q renames P;" is legal with no [with_clause](S0223)s (though not particularly interesting). ASCII is physically nested in Standard, and so is not a library unit, and cannot be renamed as a library unit. 

NOTE 2   The [designator](S0144) of a library function cannot be an [operator_symbol](S0147), but a nonlibrary [renaming_declaration](S0169) is allowed to rename a library function as an operator. Within a partition, two library subprograms are required to have distinct names and hence cannot overload each other. However, [renaming_declaration](S0169)s are allowed to define overloaded names for such subprograms, and a locally declared subprogram is allowed to overload a library subprogram. The expanded name Standard.L can be used to denote a root library unit L (unless the declaration of Standard is hidden) since root library unit declarations occur immediately within the declarative region of package Standard. 


#### Examples

Examples of library units: 

```ada
package Rational_Numbers.IO is  -- public child of Rational_Numbers, see 7.1
   procedure Put(R : in  Rational);
   procedure Get(R : out Rational);
end Rational_Numbers.IO;

```

```ada
private procedure Rational_Numbers.Reduce(R : in out Rational);
                                -- private child of Rational_Numbers

```

```ada
with Rational_Numbers.Reduce;   -- refer to a private child
package body Rational_Numbers is
   ...
end Rational_Numbers;

```

```ada
with Rational_Numbers.IO; use Rational_Numbers;
with Ada.Text_io;               -- see A.10
procedure Main is               -- a root library procedure
   R : Rational;
begin
   R := 5/3;                    -- construct a rational number, see 7.1
   Ada.Text_IO.Put("The answer is: ");
   IO.Put(R);
   Ada.Text_IO.New_Line;
end Main;

```

```ada
with Rational_Numbers.IO;
package Rational_IO renames Rational_Numbers.IO;
                                -- a library unit renaming declaration

```

Each of the above [library_item](S0216)s can be submitted to the compiler separately. 

Discussion: Example of a generic package with children:

```ada
generic
   type Element is private;
   with function Image(E : Element) return String;
package Generic_Bags is
   type Bag is limited private; -- A bag of Elements.
   procedure Add(B : in out Bag; E : Element);
   function Bag_Image(B : Bag) return String;
private
   type Bag is ...;
end Generic_Bags;

```

```ada
generic
package Generic_Bags.Generic_Iterators is
   ... -- various additional operations on Bags.

```

```ada
   generic
      with procedure Use_Element(E : in Element);
         -- Called once per bag element.
   procedure Iterate(B : in Bag);
end Generic_Bags.Generic_Iterators;

```

A package that instantiates the above generic units: 

```ada
with Generic_Bags;
with Generic_Bags.Generic_Iterators;
package My_Abstraction is
    type My_Type is ...;
    function Image(X : My_Type) return String;
    package Bags_Of_My_Type is new Generic_Bags(My_Type, Image);
    package Iterators_Of_Bags_Of_My_Type is new Bags_Of_My_Type.Generic_Iterators;
end My_Abstraction;

```

In the above example, Bags_Of_My_Type has a nested generic unit called Generic_Iterators. The second [with_clause](S0223) makes that nested unit visible.

Here we show how the generic body could depend on one of its own children: 

```ada
with Generic_Bags.Generic_Iterators;
package body Generic_Bags is
   procedure Add(B : in out Bag; E : Element) is ... end Add;

```

```ada
   package Iters is new Generic_Iterators;

```

```ada
   function Bag_Image(B : Bag) return String is
      Buffer : String(1..10_000);
      Last : Integer := 0;

```

```ada
      procedure Append_Image(E : in Element) is
         Im : constant String := Image(E);
      begin
         if Last /= 0 then -- Insert a comma.
            Last := Last + 1;
            Buffer(Last) := ',';
         end if;
         Buffer(Last+1 .. Last+Im'Length) := Im;
         Last := Last + Im'Length;
      end Append_Image;

```

```ada
      procedure Append_All is new Iters.Iterate(Append_Image);
   begin
      Append_All(B);
      return Buffer(1..Last);
   end Bag_Image;
end Generic_Bags;

```


#### Extensions to Ada 83

The syntax rule for [library_item](S0216) is modified to allow the reserved word private before a [library_unit_declaration](S0217).

Children (other than children of Standard) are new in Ada 95.

Library unit renaming is new in Ada 95. 


#### Wording Changes from Ada 83

Standard is considered a library unit in Ada 95. This simplifies the descriptions, since it implies that the parent of each library unit is a library unit. (Standard itself has no parent, of course.) As in Ada 83, the language does not define any way to recompile Standard, since the name given in the declaration of a library unit is always interpreted in relation to Standard. That is, an attempt to compile a package Standard would result in Standard.Standard. 


### 10.1.2  Context Clauses - With Clauses

[A [context_clause](S0221) is used to specify the [library_item](S0216)s whose names are needed within a compilation unit.] 


#### Language Design Principles

The reader should be able to understand a [context_clause](S0221) without looking ahead. Similarly, when compiling a [context_clause](S0221), the compiler should not have to look ahead at subsequent [context_item](S0222)s, nor at the compilation unit to which the [context_clause](S0221) is attached. (We have not completely achieved this.)


#### Syntax

context_clause ::= {[context_item](S0222)}

context_item ::= [with_clause](S0223) | [use_clause](S0166)

with_clause ::= with library_unit_[name](S0084) {, library_unit_[name](S0084)};


#### Name Resolution Rules

The scope of a [with_clause](S0223) that appears on a [library_unit_declaration](S0217) or [library_unit_renaming_declaration](S0218) consists of the entire declarative region of the declaration[, which includes all children and subunits]. The scope of a [with_clause](S0223) that appears on a body consists of the body[, which includes all subunits]. 

Discussion: Suppose a  [with_clause](S0223) of a public library unit mentions one of its private siblings. (This is only allowed on the body of the public library unit.) We considered making the scope of that [with_clause](S0223) not include the visible part of the public library unit. (This would only matter for a [subprogram_body](S0154), since those are the only kinds of body that have a visible part, and only if the [subprogram_body](S0154) completes a [subprogram_declaration](S0141), since otherwise the [with_clause](S0223) would be illegal.) We did not put in such a rule for two reasons: (1) It would complicate the wording of the rules, because we would have to split each [with_clause](S0223) into pieces, in order to correctly handle "with P, Q;" where P is public and Q is private. (2) The conformance rules prevent any problems. It doesn't matter if a type name in the spec of the body denotes the completion of a [private_type_declaration](S0164).

A [with_clause](S0223) also affects visibility within subsequent [use_clause](S0166)s and [pragma](S0016)s of the same [context_clause](S0221), even though those are not in the scope of the [with_clause](S0223). 

A [library_item](S0216) is mentioned in a [with_clause](S0223) if it is denoted by a library_unit_[name](S0084) or a [prefix](S0086) in the [with_clause](S0223). 

Discussion: [With_clause](S0223)s control the visibility of declarations or renamings of library units. Mentioning a root library unit in a [with_clause](S0223) makes its declaration directly visible. Mentioning a nonroot library unit makes its declaration visible. See Section 8 for details.

Note that this rule implies that "with A.B.C;" is equivalent to "with A, A.B, A.B.C;" The reason for making a [with_clause](S0223) apply to all the ancestor units is to avoid "visibility holes" - situations in which an inner program unit is visible while an outer one is not. Visibility holes would cause semantic complexity and implementation difficulty.

[Outside its own declarative region, the declaration or renaming of a library unit can be visible only within the scope of a [with_clause](S0223) that mentions it. The visibility of the declaration or renaming of a library unit otherwise follows from its placement in the environment.] 


#### Legality Rules

If a [with_clause](S0223) of a given [compilation_unit](S0215) mentions a private child of some library unit, then the given [compilation_unit](S0215) shall be either the declaration of a private descendant of that library unit or the body or subunit of a [(public or private)] descendant of that library unit. 

Reason: The purpose of this rule is to prevent a private child from being visible (or even semantically depended-on) from outside the subsystem rooted at its parent. 

Discussion: This rule violates the one-pass [context_clause](S0221)s Language Design Principle. We rationalize this by saying that at least that Language Design Principle works for legal compilation units.

Example: 

```ada
package A is
end A;

```

```ada
package A.B is
end A.B;

```

```ada
private package A.B.C is
end A.B.C;

```

```ada
package A.B.C.D is
end A.B.C.D;

```

```ada
with A.B.C; -- (1)
private package A.B.X is
end A.B.X;

```

```ada
package A.B.Y is
end A.B.Y;

```

```ada
with A.B.C; -- (2)
package body A.B.Y is
end A.B.Y;

```

(1) is OK because it's a private child of A.B - it would be illegal if we made A.B.X a public child of A.B. (2) is OK because it's the body of a child of A.B. It would be illegal to say "with A.B.C;" on any [library_item](S0216) whose name does not start with "A.B". Note that mentioning A.B.C.D in a [with_clause](S0223) automatically mentions A.B.C as well, so "with A.B.C.D;" is illegal in the same places as "with A.B.C;". 

To be honest: For the purposes of this rule, if a [subprogram_body](S0154) has no preceding [subprogram_declaration](S0141), the [subprogram_body](S0154) should be considered a declaration and not a body. Thus, it is illegal for such a [subprogram_body](S0154) to mention one of its siblings in a [with_clause](S0223) if the sibling is a private library unit. 

NOTE   A [library_item](S0216) mentioned in a [with_clause](S0223) of a compilation unit is visible within the compilation unit and hence acts just like an ordinary declaration. Thus, within a compilation unit that mentions its declaration, the name of a library package can be given in [use_clause](S0166)s and can be used to form expanded names, a library subprogram can be called, and instances of a generic library unit can be declared. If a child of a parent generic package is mentioned in a [with_clause](S0223), then the corresponding declaration nested within each visible instance is visible within the compilation unit.

Ramification: The rules given for [with_clause](S0223)s are such that the same effect is obtained whether the name of a library unit is mentioned once or more than once by the applicable [with_clause](S0223)s, or even within a given [with_clause](S0223).

If a [with_clause](S0223) mentions a [library_unit_renaming_declaration](S0218), it only "mentions" the [prefix](S0086)es appearing explicitly in the [with_clause](S0223) (and the renamed view itself); the [with_clause](S0223) is not defined to mention the ancestors of the renamed entity. Thus, if X renames Y.Z, then "with X;" does not make the declarations of Y or Z visible. Note that this does not cause the dreaded visibility holes mentioned above. 


#### Extensions to Ada 83

The syntax rule for [with_clause](S0223) is modified to allow expanded name notation.

A [use_clause](S0166) in a [context_clause](S0221) may be for a package (or type) nested in a library package. 


#### Wording Changes from Ada 83

The syntax rule for [context_clause](S0221) is modified to more closely reflect the semantics. The Ada 83 syntax rule implies that the [use_clause](S0166)s that appear immediately after a particular [with_clause](S0223) are somehow attached to that [with_clause](S0223), which is not true. The new syntax allows a [use_clause](S0166) to appear first, but that is prevented by a textual rule that already exists in Ada 83.

The concept of "scope of a [with_clause](S0223)" (which is a region of text) replaces RM83's notion of "apply to" (a [with_clause](S0223) applies to a [library_item](S0216)) The visibility rules are interested in a region of text, not in a set of compilation units.

No need to define "apply to" for [use_clause](S0166)s. Their semantics are fully covered by the "scope (of a [use_clause](S0166))" definition in 8.4. 


### 10.1.3  Subunits of Compilation Units

[Subunits are like child units, with these (important) differences: subunits support the separate compilation of bodies only (not declarations); the parent contains a [body_stub](S0224) to indicate the existence and place of each of its subunits; declarations appearing in the parent's body can be visible within the subunits.] 


#### Syntax

body_stub ::= 
   [subprogram_body_stub](S0225) | [package_body_stub](S0226) | [task_body_stub](S0227) | [protected_body_stub](S0228)

subprogram_body_stub ::= [subprogram_specification](S0143) is separate;

Discussion: Although this syntax allows a [parent_unit_name](S0220), that is disallowed by 10.1.1, "Compilation Units - Library Units". 

package_body_stub ::= package body [defining_identifier](S0019) is separate;

task_body_stub ::= task body [defining_identifier](S0019) is separate;

protected_body_stub ::= protected body [defining_identifier](S0019) is separate;

subunit ::= separate ([parent_unit_name](S0220)) [proper_body](S0083)


#### Legality Rules

The parent body of a subunit is the body of the program unit denoted by its [parent_unit_name](S0220).  The term subunit is used to refer to a [subunit](S0229) and also to the [proper_body](S0083) of a [subunit](S0229). 

Version=[5],Kind=(AddedNormal),Group=[C],Term=[subunit], Def=[the body of a program unit that can be compiled separately from its enclosing program unit]

The parent body of a subunit shall be present in the current environment, and shall contain a corresponding [body_stub](S0224) with the same [defining_identifier](S0019) as the subunit. 

Discussion: This can't be a Name Resolution Rule, because a [subunit](S0229) is not a complete context. 

A [package_body_stub](S0226) shall be the completion of a [package_declaration](S0161) or [generic_package_declaration](S0238); a [task_body_stub](S0227) shall be the completion of a task_declaration; a [protected_body_stub](S0228) shall be the completion of a protected_declaration.

In contrast, a [subprogram_body_stub](S0225) need not be the completion of a previous declaration, [in which case the _stub declares the subprogram]. If the _stub is a completion, it shall be the completion of a [subprogram_declaration](S0141) or [generic_subprogram_declaration](S0237). The profile of a [subprogram_body_stub](S0225) that completes a declaration shall conform fully to that of the declaration. 

Discussion: The part about [subprogram_body_stub](S0225)s echoes the corresponding rule for subprogram_bodies in 6.3, "Subprogram Bodies". 

A subunit that corresponds to a [body_stub](S0224) shall be of the same kind (package_, subprogram_, task_, or protected_) as the [body_stub](S0224). The profile of a [subprogram_body](S0154) subunit shall be fully conformant to that of the corresponding [body_stub](S0224). 

A [body_stub](S0224) shall appear immediately within the [declarative_part](S0079) of a compilation unit body. This rule does not apply within an instance of a generic unit. 

Discussion: This is a methodological restriction; that is, it is not necessary for the semantics of the language to make sense. 

The [defining_identifier](S0019)s of all [body_stub](S0224)s that appear immediately within a particular [declarative_part](S0079) shall be distinct. 


#### Post-Compilation Rules

For each [body_stub](S0224), there shall be a subunit containing the corresponding [proper_body](S0083). 

NOTE   The rules in 10.1.4, "The Compilation Process" say that a [body_stub](S0224) is equivalent to the corresponding [proper_body](S0083). This implies: 

Visibility within a subunit is the visibility that would be obtained at the place of the corresponding [body_stub](S0224) (within the parent body) if the [context_clause](S0221) of the subunit were appended to that of the parent body. 

Ramification: Recursively. Note that this transformation might make the parent illegal; hence it is not a true equivalence, but applies only to visibility within the subunit. 

The effect of the elaboration of a [body_stub](S0224) is to elaborate the subunit. 

Ramification: The elaboration of a subunit is part of its parent body's elaboration, whereas the elaboration of a child unit is not part of its parent declaration's elaboration. 

Ramification: A [library_item](S0216) that is mentioned in a [with_clause](S0223) of a subunit can be hidden (from direct visiblity) by a declaration (with the same [identifier](S0002)) given in the subunit. Moreover, such a [library_item](S0216) can even be hidden by a declaration given within the parent body since a library unit is declared in its parent's declarative region; this however does not affect the interpretation of the [with_clause](S0223)s themselves, since only [library_item](S0216)s are visible or directly visible in [with_clause](S0223)s.

The body of a protected operation cannot be a subunit. This follows from the syntax rules. The body of a protected unit can be a subunit. 


#### Examples

The package Parent is first written without subunits: 

```ada
package Parent is
    procedure Inner;
end Parent;

```

```ada
with Ada.Text_IO;
package body Parent is
    Variable : String := "Hello, there.";
    procedure Inner is
    begin
        Ada.Text_IO.Put_Line(Variable);
    end Inner;
end Parent;

```

The body of procedure Inner may be turned into a subunit by rewriting the package body as follows (with the declaration of Parent remaining the same): 

```ada
package body Parent is
    Variable : String := "Hello, there.";
    procedure Inner is separate;
end Parent;

```

```ada
with Ada.Text_IO;
separate(Parent)
procedure Inner is
begin
    Ada.Text_IO.Put_Line(Variable);
end Inner;

```


#### Extensions to Ada 83

Subunits of the same ancestor library unit are no longer restricted to have distinct identifiers. Instead, we require only that the full expanded names be distinct. 


### 10.1.4  The Compilation Process

Each compilation unit submitted to the compiler is compiled in the context of an environment [declarative_part](S0079) (or simply, an environment), which is a conceptual [declarative_part](S0079) that forms the outermost declarative region of the context of any [compilation](S0214). At run time, an environment forms the [declarative_part](S0079) of the body of the environment task of a partition (see 10.2, "Program Execution"). 

Ramification: At compile time, there is no particular construct that the declarative region is considered to be nested within - the environment is the universe. 

To be honest: The environment is really just a portion of a [declarative_part](S0079), since there might, for example, be bodies that do not yet exist. 

The [declarative_item](S0080)s of the environment are [library_item](S0216)s appearing in an order such that there are no forward semantic dependences. Each included subunit occurs in place of the corresponding stub. The visibility rules apply as if the environment were the outermost declarative region, except that [with_clause](S0223)s are needed to make declarations of library units visible (see 10.1.2).

The mechanisms for creating an environment and for adding and replacing compilation units within an environment are implementation defined. 

Implementation defined: The mechanisms for creating an environment and for adding and replacing compilation units.

Ramification: The traditional model, used by most Ada 83 implementations, is that one places a compilation unit in the environment by compiling it. Other models are possible. For example, an implementation might define the environment to be a directory; that is, the compilation units in the environment are all the compilation units in the source files contained in the directory. In this model, the mechanism for replacing a compilation unit with a new one is simply to edit the source file containing that compilation unit. 


#### Name Resolution Rules

If a [library_unit_body](S0219) that is a [subprogram_body](S0154) is submitted to the compiler, it is interpreted only as a completion if a [library_unit_declaration](S0217) for a subprogram or a generic subprogram with the same [defining_program_unit_name](S0146) already exists in the environment (even if the profile of the body is not type conformant with that of the declaration); otherwise the [subprogram_body](S0154) is interpreted as both the declaration and body of a library subprogram. 

Ramification: The principle here is that a [subprogram_body](S0154) should be interpreted as only a completion if and only if it "might" be legal as the completion of some preexisting declaration, where "might" is defined in a way that does not require overload resolution to determine.

Hence, if the preexisting declaration is a [subprogram_declaration](S0141) or [generic_subprogram_declaration](S0237), we treat the new [subprogram_body](S0154) as its completion, because it "might" be legal. If it turns out that the profiles don't fully conform, it's an error. In all other cases (the preexisting declaration is a package or a generic package, or an instance of a generic subprogram, or a renaming, or a "spec-less" subprogram, or in the case where there is no preexisting thing), the [subprogram_body](S0154) declares a new subprogram.

See also AI83-00266/09. 


#### Legality Rules

When a compilation unit is compiled, all compilation units upon which it depends semantically shall already exist in the environment; the set of these compilation units shall be consistent in the sense that the new compilation unit shall not semantically depend (directly or indirectly) on two different versions of the same compilation unit, nor on an earlier version of itself. 

Discussion: For example, if package declarations A and B both say "with X;", and the user compiles a compilation unit that says "with A, B;", then the A and B have to be talking about the same version of X. 

Ramification: What it means to be a "different version" is not specified by the language. In some implementations, it means that the compilation unit has been recompiled. In others, it means that the source of the compilation unit has been edited in some significant way.

Note that an implementation cannot require the existence of compilation units upon which the given one does not semantically depend. For example, an implementation is required to be able to compile a compilation unit that says "with A;" when A's body does not exist. It has to be able to detect errors without looking at A's body.

Similarly, the implementation has to be able to compile a call to a subprogram for which a [pragma](S0016) Inline has been specified without seeing the body of that subprogram - inlining would not be achieved in this case, but the call is still legal.


#### Implementation Permissions

The implementation may require that a compilation unit be legal before inserting it into the environment.

When a compilation unit that declares or renames a library unit is added to the environment, the implementation may remove from the environment any preexisting [library_item](S0216) with the same [defining_program_unit_name](S0146). When a compilation unit that is a subunit or the body of a library unit is added to the environment, the implementation may remove from the environment any preexisting version of the same compilation unit. When a given compilation unit is removed from the environment, the implementation may also remove any compilation unit that depends semantically upon the given one. If the given compilation unit contains the body of a subprogram to which a [pragma](S0016) Inline applies, the implementation may also remove any compilation unit containing a call to that subprogram. 

Ramification: The permissions given in this paragraph correspond to the traditional model, where compilation units enter the environment by being compiled into it, and the compiler checks their legality at that time. A implementation model in which the environment consists of all source files in a given directory might not want to take advantage of these permissions. Compilation units would not be checked for legality as soon as they enter the environment; legality checking would happen later, when compilation units are compiled. In this model, compilation units might never be automatically removed from the environment; they would be removed when the user explicitly deletes a source file.

Note that the rule is recursive: if the above permission is used to remove a compilation unit containing an inlined subprogram call, then compilation units that depend semantically upon the removed one may also be removed, and so on.

Note that here we are talking about dependences among existing compilation units in the environment; it doesn't matter what [with_clause](S0223)s are attached to the new compilation unit that triggered all this.

An implementation may have other modes in which compilation units in addition to the ones mentioned above are removed. For example, an implementation might inline subprogram calls without an explicit [pragma](S0016) Inline. If so, it either has to have a mode in which that optimization is turned off, or it has to automatically regenerate code for the inlined calls without requiring the user to resubmit them to the compiler. 

NOTE 1   The rules of the language are enforced across [compilation](S0214) and compilation unit boundaries, just as they are enforced within a single compilation unit. 

Ramification: Note that Section 1 requires an implementation to detect illegal compilation units at compile time. 

NOTE 2   An implementation may support a concept of a library, which contains [library_item](S0216)s. If multiple libraries are supported, the implementation has to define how a single environment is constructed when a compilation unit is submitted to the compiler. Naming conflicts between different libraries might be resolved by treating each library as the root of a hierarchy of child library units. 

Implementation Note: Alternatively, naming conflicts could be resolved via some sort of hiding rule. 

Discussion: For example, the implementation might support a command to import library Y into library X. If a root library unit called LU (that is, Standard.LU) exists in Y, then from the point of view of library X, it could be called Y.LU. X might contain library units that say, "with Y.LU;". 

NOTE 3   A compilation unit containing an instantiation of a separately compiled generic unit does not semantically depend on the body of the generic unit. Therefore, replacing the generic body in the environment does not result in the removal of the compilation unit containing the instantiation. 

Implementation Note: Therefore, implementations have to be prepared to automatically instantiate generic bodies at link-time, as needed. This might imply a complete automatic recompilation, but it is the intent of the language that generic bodies can be (re)instantiated without forcing all of the compilation units that semantically depend on the compilation unit containing the instantiation to be recompiled. 


### 10.1.5  Pragmas and Program Units

[This subclause discusses pragmas related to program units, library units, and [compilation](S0214)s.] 


#### Name Resolution Rules

Certain [pragma](S0016)s are defined to be program unit pragmas. A [name](S0084) given as the argument of a program unit pragma shall resolve to denote the declarations or renamings of one or more program units that occur immediately within the declarative region or [compilation](S0214) in which the [pragma](S0016) immediately occurs, or it shall resolve to denote the declaration of the immediately enclosing program unit (if any); the [pragma](S0016) applies to the denoted program unit(s). If there are no [name](S0084)s given as arguments, the [pragma](S0016) applies to the immediately enclosing program unit. 

Ramification: The fact that this is a Name Resolution Rule means that the [pragma](S0016) will not apply to declarations from outer declarative regions. 


#### Legality Rules

A program unit pragma shall appear in one of these places: 

At the place of a [compilation_unit](S0215), in which case the [pragma](S0016) shall immediately follow in the same [compilation](S0214) (except for other [pragma](S0016)s) a [library_unit_declaration](S0217) that is a [subprogram_declaration](S0141), [generic_subprogram_declaration](S0237), or [generic_instantiation](S0241), and the [pragma](S0016) shall have an argument that is a [name](S0084) denoting that declaration. 

Ramification: The [name](S0084) has to denote the immediately preceding [library_unit_declaration](S0217). 

Immediately within the declaration of a program unit and before any nested declaration, in which case the argument, if any, shall be a [direct_name](S0085) that denotes the immediately enclosing program unit declaration. 

Ramification: The argument is optional in this case. 

At the place of a declaration other than the first, of a [declarative_part](S0079) or program unit declaration, in which case the [pragma](S0016) shall have an argument, which shall be a [direct_name](S0085) that denotes one or more of the following (and nothing else): a [subprogram_declaration](S0141), a [generic_subprogram_declaration](S0237), or a [generic_instantiation](S0241), of the same [declarative_part](S0079) or program unit declaration. 

Ramification: If you want to denote a [subprogram_body](S0154) that is not a completion, or a [package_declaration](S0161), for example, you have to put the [pragma](S0016) inside. 

Certain program unit pragmas are defined to be library unit pragmas. The [name](S0084), if any, in a library unit pragma shall denote the declaration of a library unit. 

Ramification: This, together with the rules for program unit pragmas above, implies that if a library unit pragma applies to a [subprogram_declaration](S0141) (and similar things), it has to appear immediately after the [compilation_unit](S0215), whereas if the [pragma](S0016) applies to a [package_declaration](S0161), a [subprogram_body](S0154) that is not a completion (and similar things), it has to appear inside, as the first [declarative_item](S0080). 


#### Post-Compilation Rules

Certain [pragma](S0016)s are defined to be configuration pragmas; they shall appear before the first [compilation_unit](S0215) of a [compilation](S0214). [They are generally used to select a partition-wide or system-wide option.] The [pragma](S0016) applies to all [compilation_unit](S0215)s appearing in the [compilation](S0214), unless there are none, in which case it applies to all future [compilation_unit](S0215)s compiled into the same environment. 


#### Implementation Permissions

An implementation may place restrictions on configuration pragmas, so long as it allows them when the environment contains no [library_item](S0216)s other than those of the predefined environment. 

This paragraph was deleted.Implementation Advice: 


### 10.1.6  Environment-Level Visibility Rules

[The normal visibility rules do not apply within a [parent_unit_name](S0220) or a [context_clause](S0221), nor within a [pragma](S0016) that appears at the place of a compilation unit. The special visibility rules for those contexts are given here.] 


#### Static Semantics

Within the [parent_unit_name](S0220) at the beginning of a [library_item](S0216), and within a [with_clause](S0223), the only declarations that are visible are those that are [library_item](S0216)s of the environment, and the only declarations that are directly visible are those that are root [library_item](S0216)s of the environment. Notwithstanding the rules of 4.1.3, an expanded name in a [with_clause](S0223) may consist of a [prefix](S0086) that denotes a generic package and a [selector_name](S0092) that denotes a child of that generic package. [(The child is necessarily a generic unit; see 10.1.1.)]

Ramification: In "package P.Q.R is ... end P.Q.R;", this rule requires P to be a root library unit, and Q to be a library unit (because those are the things that are directly visible and visible). Note that visibility does not apply between the "end" and the ";".

Physically nested declarations are not visible at these places.

Although Standard is visible at these places, it is impossible to name it, since it is not directly visible, and it has no parent.

Reason: The "notwithstanding" part allows "with A.B;" where A is a generic library package and B is one of its (generic) children. This is necessary because it is not normally legal to use an expanded name to reach inside a generic package. 

Within a [use_clause](S0166) or [pragma](S0016) that is within a [context_clause](S0221), each [library_item](S0216) mentioned in a previous [with_clause](S0223) of the same [context_clause](S0221) is visible, and each root [library_item](S0216) so mentioned is directly visible. In addition, within such a [use_clause](S0166), if a given declaration is visible or directly visible, each declaration that occurs immediately within the given declaration's visible part is also visible. No other declarations are visible or directly visible. 

Discussion: Note the word "same". For example, if a [with_clause](S0223) on a declaration mentions X, this does not make X visible in [use_clause](S0166)s and [pragma](S0016)s that are on the body. The reason for this rule is the one-pass [context_clause](S0221)s Language Design Principle.

Note that the second part of the rule does not mention [pragma](S0016)s. 

Within the [parent_unit_name](S0220) of a subunit, [library_item](S0216)s are visible as they are in the [parent_unit_name](S0220) of a [library_item](S0216); in addition, the declaration corresponding to each [body_stub](S0224) in the environment is also visible. 

Ramification: For a subprogram without a separate [subprogram_declaration](S0141), the [body_stub](S0224) itself is the declaration. 

Within a [pragma](S0016) that appears at the place of a compilation unit, the immediately preceding [library_item](S0216) and each of its ancestors is visible. The ancestor root [library_item](S0216) is directly visible.


#### Wording Changes from Ada 83

The special visibility rules that apply within a [parent_unit_name](S0220) or a [context_clause](S0221), and within a [pragma](S0016) that appears at the place of a [compilation_unit](S0215) are clarified.

Note that a [context_clause](S0221) is not part of any declarative region.

We considered making the visibility rules within [parent_unit_name](S0220)s and [context_clause](S0221)s follow from the context of compilation. However, this attempt failed for various reasons. For example, it would require [use_clause](S0166)s in [context_clause](S0221)s to be within the declarative region of Standard, which sounds suspiciously like a kludge. And we would still need a special rule to prevent seeing things (in our own [context_clause](S0221)) that were with-ed by our parent, etc. 


## 10.2  Program Execution

An Ada program consists of a set of partitions[, which can execute in parallel with one another, possibly in a separate address space, and possibly on a separate computer.] 


#### Post-Compilation Rules

A partition is a program or part of a program that can be invoked from outside the Ada implementation. [For example, on many systems, a partition might be an executable file generated by the system linker.] The user can explicitly assign library units to a partition. The assignment is done in an implementation-defined manner. The compilation units included in a partition are those of the explicitly assigned library units, as well as other compilation units needed by those library units. The compilation units needed by a given compilation unit are determined as follows (unless specified otherwise via an implementation-defined [pragma](S0016), or by some other implementation-defined means): 

Discussion: From a run-time point of view, an Ada 95 partition is identical to an Ada 83 program - implementations were always allowed to provide inter-program communication mechanisms. The additional semantics of partitions is that interfaces between them can be defined to obey normal language rules (as is done in Annex E, "Distributed Systems"), whereas interfaces between separate programs had no particular semantics. 

Implementation defined: The manner of explicitly assigning library units to a partition.

Implementation defined: The implementation-defined means, if any, of specifying which compilation units are needed by a given compilation unit.

Discussion: There are no pragmas that "specify otherwise" defined by the core language. However, an implementation is allowed to provide such pragmas, and in fact Annex E, "Distributed Systems" defines some pragmas whose semantics includes reducing the set of compilation units described here. 

Version=[5],Kind=(AddedNormal),Group=[C],Term=[needed compilation unit], Def=[a compilation unit that is necessary to produce an executable partition, because some entity declared or defined within the unit is used elsewhere in the partition]

A compilation unit needs itself;

If a compilation unit is needed, then so are any compilation units upon which it depends semantically;

If a [library_unit_declaration](S0217) is needed, then so is any corresponding [library_unit_body](S0219);

If a compilation unit with stubs is needed, then so are any corresponding subunits.

Discussion: Note that in the environment, the stubs are replaced with the corresponding proper_bodies. 

Discussion: Note that a child unit is not included just because its parent is included - to include a child, mention it in a [with_clause](S0223).

The user can optionally designate (in an implementation-defined manner) one subprogram as the main subprogram for the partition. A main subprogram, if specified, shall be a subprogram. 

Discussion: This may seem superfluous, since it follows from the definition. But we would like to have every error message that might be generated (before run time) by an implementation correspond to some explicitly stated "shall" rule.

Of course, this does not mean that the "shall" rules correspond one-to-one with an implementation's error messages. For example, the rule that says overload resolution "shall" succeed in producing a single interpretation would correspond to many error messages in a good implementation - the implementation would want to explain to the user exactly why overload resolution failed. This is especially true for the syntax rules - they are considered part of overload resolution, but in most cases, one would expect an error message based on the particular syntax rule that was violated. 

Implementation defined: The manner of designating the main subprogram of a partition.

Ramification: An implementation cannot require the user to specify, say, all of the library units to be included. It has to support, for example, perhaps the most typical case, where the user specifies just one library unit, the main program. The implementation has to do the work of tracking down all the other ones. 

Each partition has an anonymous environment task[, which is an implicit outermost task whose execution elaborates the [library_item](S0216)s of the environment [declarative_part](S0079), and then calls the main subprogram, if there is one. A partition's execution is that of its tasks.] 

Ramification: An environment task has no master; all nonenvironment tasks have masters.

An implementation is allowed to support multiple concurrent executions of the same partition. 

[The order of elaboration of library units is determined primarily by the elaboration dependences.] There is an elaboration dependence of a given [library_item](S0216) upon another if the given [library_item](S0216) or any of its subunits depends semantically on the other [library_item](S0216). In addition, if a given [library_item](S0216) or any of its subunits has a [pragma](S0016) Elaborate or Elaborate_All that mentions another library unit, then there is an elaboration dependence of the given [library_item](S0216) upon the body of the other library unit, and, for Elaborate_All only, upon each [library_item](S0216) needed by the declaration of the other library unit. 

Discussion: See above for a definition of which [library_item](S0216)s are "needed by" a given declaration.

Note that elaboration dependences are among [library_item](S0216)s, whereas the other two forms of dependence are among compilation units. Note that elaboration dependence includes semantic dependence. It's a little bit sad that pragma Elaborate_Body  can't be folded into this mechanism. It follows from the definition that the elaboration dependence relationship is transitive. Note that the wording of the rule does not need to take into account a semantic dependence of a [library_item](S0216) or one of its subunits upon a subunit of a different library unit, because that can never happen. 

The environment task for a partition has the following structure: 

```ada
task Environment_Task;

```

```ada
task body Environment_Task is
    ... (1) -- The environment [declarative_part](S0079)
            -- (that is, the sequence of [library_item](S0216)s) goes here.
begin
    ... (2) -- Call the main subprogram, if there is one.
end Environment_Task;

```

Ramification: The name of the environment task is written in italics here to indicate that this task is anonymous. 

Discussion: The model is different for a "passive partition" (see E.1). Either there is no environment task, or its [sequence_of_statements](S0123) is an infinite loop rather than a call on a main subprogram. 

The environment [declarative_part](S0079) at (1) is a sequence of [declarative_item](S0080)s consisting of copies of the [library_item](S0216)s included in the partition[. The order of elaboration of [library_item](S0216)s is the order in which they appear in the environment [declarative_part](S0079)]: 

The order of all included [library_item](S0216)s is such that there are no forward elaboration dependences. 

Ramification: This rule is written so that if a [library_item](S0216) depends on itself, we don't require it to be elaborated before itself. See AI83-00113/12. This can happen only in pathological circumstances. For example, if a library [subprogram_body](S0154) has no corresponding [subprogram_declaration](S0141), and one of the subunits of the [subprogram_body](S0154) mentions the [subprogram_body](S0154) in a [with_clause](S0223), the [subprogram_body](S0154) will depend on itself. For another example, if a [library_unit_body](S0219) applies a [pragma](S0016) Elaborate_All to its own declaration, then the [library_unit_body](S0219) will depend on itself. 

Any included [library_unit_declaration](S0217) to which a [pragma](S0016) Elaborate_Body applies is immediately followed by its [library_unit_body](S0219), if included. 

Discussion: This implies that the body of such a library unit shall not "with" any of its own children, or anything else that depends semantically upon the declaration of the library unit. 

All [library_item](S0216)s declared pure occur before any that are not declared pure.

All preelaborated [library_item](S0216)s occur before any that are not preelaborated. 

Discussion: Normally, if two partitions contain the same compilation unit, they each contain a separate copy of that compilation unit. See Annex E, "Distributed Systems" for cases where two partitions share the same copy of something.

There is no requirement that the main subprogram be elaborated last. In fact, it is possible to write a partition in which the main subprogram cannot be elaborated last. 

Ramification: This [declarative_part](S0079) has the properties required of all environments (see 10.1.4). However, the environment [declarative_part](S0079) of a partition will typically contain fewer compilation units than the environment [declarative_part](S0079) used at compile time - only the "needed" ones are included in the partition. 

There shall be a total order of the [library_item](S0216)s that obeys the above rules. The order is otherwise implementation defined. 

Discussion: The only way to violate this rule is to have Elaborate, Elaborate_All, or Elaborate_Body [pragma](S0016)s that cause circular ordering requirements, thus preventing an order that has no forward elaboration dependences. 

Implementation defined: The order of elaboration of [library_item](S0216)s.

To be honest: Notwithstanding what the RM95 says elsewhere, each rule that requires a declaration to have a corresponding completion is considered to be a Post-Compilation Rule when the declaration is that of a library unit. 

Discussion: Such rules may be checked at "link time", for example. Rules requiring the completion to have certain properties, on the other hand, are checked at compile time of the completion. 

The full expanded names of the library units and subunits included in a given partition shall be distinct.

Reason: This is a Post-Compilation Rule because making it a Legality Rule would violate the Language Design Principle labeled "legality determinable via semantic dependences". 

The [sequence_of_statements](S0123) of the environment task (see (2) above) consists of either: 

A call to the main subprogram, if the partition has one. If the main subprogram has parameters, they are passed; where the actuals come from is implementation defined. What happens to the result of a main function is also implementation defined. 

Implementation defined: Parameter passing and function return for the main subprogram.

or: 

A [null_statement](S0127), if there is no main subprogram. 

Discussion: For a passive partition, either there is no environment task, or its [sequence_of_statements](S0123) is an infinite loop. See E.1. 

The mechanisms for building and running partitions are implementation defined. [These might be combined into one operation, as, for example, in dynamic linking, or "load-and-go" systems.] 

Implementation defined: The mechanisms for building and running partitions.


#### Dynamic Semantics

The execution of a program consists of the execution of a set of partitions. Further details are implementation defined. The execution of a partition starts with the execution of its environment task, ends when the environment task terminates, and includes the executions of all tasks of the partition. [The execution of the (implicit) [task_body](S0179) of the environment task acts as a master for all other tasks created as part of the execution of the partition. When the environment task completes (normally or abnormally), it waits for the termination of all such tasks, and then finalizes any remaining objects of the partition.] 

Ramification: The "further details" mentioned above include, for example, program termination - it is implementation defined. There is no need to define it here; it's entirely up to the implementation whether it wants to consider the program as a whole to exist beyond the existence of individual partitions. 

Implementation defined: The details of program execution, including program termination.

To be honest: The execution of the partition terminates (normally or abnormally) when the environment task terminates (normally or abnormally, respectively). 


#### Bounded (Run-Time) Errors

Once the environment task has awaited the termination of all other tasks of the partition, any further attempt to create a task (during finalization) is a bounded error, and may result in the raising of Program_Error either upon creation or activation of the task. If such a task is activated, it is not specified whether the task is awaited prior to termination of the environment task. 


#### Implementation Requirements

The implementation shall ensure that all compilation units included in a partition are consistent with one another, and are legal according to the rules of the language. 

Discussion: The consistency requirement implies that a partition cannot contain two versions of the same compilation unit. That is, a partition cannot contain two different library units with the same full expanded name, nor two different bodies for the same program unit. For example, suppose we compile the following: 

```ada
package A is -- Version 1.
    ...
end A;

```

```ada
with A;
package B is
end B;

```

```ada
package A is -- Version 2.
    ...
end A;

```

```ada
with A;
package C is
end C;

```

It would be wrong for a partition containing B and C to contain both versions of A. Typically, the implementation would require the use of Version 2 of A, which might require the recompilation of B. Alternatively, the implementation might automatically recompile B when the partition is built. A third alternative would be an incremental compiler that, when Version 2 of A is compiled, automatically patches the object code for B to reflect the changes to A (if there are any relevant changes - there might not be any).

An implementation that supported fancy version management might allow the use of Version 1 in some circumstances. In no case can the implementation allow the use of both versions in the same partition (unless, of course, it can prove that the two versions are semantically identical).

The core language says nothing about inter-partition consistency; see also Annex E, "Distributed Systems". 


#### Implementation Permissions

The kind of partition described in this clause is known as an active partition. An implementation is allowed to support other kinds of partitions, with implementation-defined semantics. 

Implementation defined: The semantics of any nonactive partitions supported by the implementation.

Discussion: Annex E, "Distributed Systems" defines the concept of passive partitions; they may be thought of as a partition without an environment task, or as one with a particularly simple form of environment task, having an infinite loop rather than a call on a main subprogram as its [sequence_of_statements](S0123). 

An implementation may restrict the kinds of subprograms it supports as main subprograms. However, an implementation is required to support all main subprograms that are public parameterless library procedures. 

Ramification: The implementation is required to support main subprograms that are procedures declared by [generic_instantiation](S0241)s, as well as those that are children of library units other than Standard. Generic units are, of course, not allowed to be main subprograms, since they are not subprograms.

Note that renamings are irrelevant to this rule. This rules says which subprograms (not views) have to be supported. The implementation can choose any way it wants for the user to indicate which subprogram should be the main subprogram. An implementation might allow any name of any view, including those declared by renamings. Another implementation might require it to be the original name. Another implementation still might use the name of the source file or some such thing. 

If the environment task completes abnormally, the implementation may abort any dependent tasks. 

Reason: If the implementation does not take advantage of this permission, the normal action takes place - the environment task awaits those tasks.

The possibility of aborting them is not shown in the Environment_Task code above, because there is nowhere to put an [exception_handler](S0232) that can handle exceptions raised in both the environment [declarative_part](S0079) and the main subprogram, such that the dependent tasks can be aborted. If we put an [exception_handler](S0232) in the body of the environment task, then it won't handle exceptions that occur during elaboration of the environment [declarative_part](S0079). If we were to move those things into a nested [block_statement](S0138), with the [exception_handler](S0232) outside that, then the [block_statement](S0138) would await the library tasks we are trying to abort.

Furthermore, this is merely a permission, and is not fundamental to the model, so it is probably better to state it separately anyway.

Note that implementations (and tools like debuggers) can have modes that provide other behaviors in addition. 

NOTE 1   An implementation may provide inter-partition communication mechanism(s) via special packages and pragmas. Standard pragmas for distribution and methods for specifying inter-partition communication are defined in Annex E, "Distributed Systems". If no such mechanisms are provided, then each partition is isolated from all others, and behaves as a program in and of itself. 

Ramification: Not providing such mechanisms is equivalent to disallowing multi-partition programs.

An implementation may provide mechanisms to facilitate checking the consistency of library units elaborated in different partitions; Annex E, "Distributed Systems" does so. 

NOTE 2   Partitions are not required to run in separate address spaces. For example, an implementation might support dynamic linking via the partition concept.

NOTE 3   An order of elaboration of [library_item](S0216)s that is consistent with the partial ordering defined above does not always ensure that each [library_unit_body](S0219) is elaborated before any other compilation unit whose elaboration necessitates that the [library_unit_body](S0219) be already elaborated. (In particular, there is no requirement that the body of a library unit be elaborated as soon as possible after the [library_unit_declaration](S0217) is elaborated, unless the pragmas in subclause 10.2.1 are used.)

NOTE 4   A partition (active or otherwise) need not have a main subprogram. In such a case, all the work done by the partition would be done by elaboration of various [library_item](S0216)s, and by tasks created by that elaboration. Passive partitions, which cannot have main subprograms, are defined in Annex E, "Distributed Systems". 

Ramification: The environment task is the outermost semantic level defined by the language.

Standard has no private part. This prevents strange implementation-dependences involving private children of Standard having visibility upon Standard's private part. It doesn't matter where the body of Standard appears in the environment, since it doesn't do anything. See Annex A, "Predefined Language Environment".

Note that elaboration dependence is carefully defined in such a way that if (say) the body of something doesn't exist yet, then there is no elaboration dependence upon the nonexistent body. (This follows from the fact that "needed by" is defined that way, and the elaboration dependences caused by a [pragma](S0016) Elaborate or Elaborate_All are defined in terms of "needed by".) This property allows us to use the environment concept both at compile time and at partition-construction time/run time. 


#### Extensions to Ada 83

The concept of partitions is new to Ada 95.

A main subprogram is now optional. The language-defined restrictions on main subprograms are relaxed. 


#### Wording Changes from Ada 83

Ada 95 uses the term "main subprogram" instead of Ada 83's "main program" (which was inherited from Pascal). This is done to avoid confusion - a main subprogram is a subprogram, not a program. The program as a whole is an entirely different thing. 


### 10.2.1  Elaboration Control

[ This subclause defines pragmas that help control the elaboration order of [library_item](S0216)s.] 


#### Language Design Principles

The rules governing preelaboration are designed to allow it to be done largely by bulk initialization of statically allocated storage from information in a "load module" created by a linker. Some implementations may require run-time code to be executed in some cases, but we consider these cases rare enough that we need not further complicate the rules.

It is important that programs be able to declare data structures that are link-time initialized with [aggregate](S0097)s, [string_literal](S0013)s, and concatenations thereof. It is important to be able to write link-time evaluated expressions involving the First, Last, and Length attributes of such data structures (including variables), because they might be initialized with positional [aggregate](S0097)s or [string_literal](S0013)s, and we don't want the user to have to count the elements. There is no corresponding need for accessing discriminants, since they can be initialized with a static constant, and then the constant can be referred to elsewhere. It is important to allow link-time initialized data structures involving discriminant-dependent components. It is important to be able to write link-time evaluated expressions involving pointers (both access values and addresses) to the above-mentioned data structures.

The rules also ensure that no Elaboration_Check need be performed for calls on library-level subprograms declared within a preelaborated package. This is true also of the Elaboration_Check on task activation for library level task types declared in a preelaborated package. However, it is not true of the Elaboration_Check on instantiations.

A static expression should never prevent a library unit from being preelaborable.


#### Syntax

The form of a [pragma](S0016) Preelaborate is as follows: 

  pragma Preelaborate[(library_unit_[name](S0084))];

A [pragma](S0016) Preelaborate is a library unit pragma. 

  


#### Legality Rules

An elaborable construct is preelaborable unless its elaboration performs any of the following actions: 

Ramification: A preelaborable construct can be elaborated without using any information that is available only at run time. Note that we don't try to prevent exceptions in preelaborable constructs; if the implementation wishes to generate code to raise an exception, that's OK.

Because there is no flow of control and there are no calls (other than to predefined subprograms), these run-time properties can actually be detected at compile time. This is necessary in order to require compile-time enforcement of the rules. 

The execution of a [statement](S0124) other than a [null_statement](S0127). 

Ramification: A preelaborable construct can contain [label](S0128)s and [null_statement](S0127)s. 

A call to a subprogram other than a static function. 

The evaluation of a [primary](S0113) that is a [name](S0084) of an object, unless the [name](S0084) is a static expression, or statically denotes a discriminant of an enclosing type. 

Ramification: One can evaluate such a [name](S0084), but not as a [primary](S0113). For example, one can evaluate an attribute of the object. One can evaluate an [attribute_reference](S0093), so long as it does not denote an object, and its [prefix](S0086) does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, and Obj'Address are generally legal in preelaborated library units. 

The creation of a default-initialized object [(including a component)] of a descendant of a private type, private extension, controlled type, task type, or protected type with [entry_declaration](S0187)s; similarly the evaluation of an [extension_aggregate](S0102) with an ancestor [subtype_mark](S0025) denoting a subtype of such a type.

Ramification: One can declare these kinds of types, but one cannot create objects of those types.

It is also nonpreelaborable to create an object if that will cause the evaluation of a default expression that will call a user-defined function. This follows from the rule above forbidding nonnull statements. 

Reason: Controlled objects are disallowed because most implementations will have to take some run-time action during initialization, even if the Initialize procedure is null. 

A generic body is preelaborable only if elaboration of a corresponding instance body would not perform any such actions, presuming that the actual for each formal private type (or extension) is a private type (or extension), and the actual for each formal subprogram is a user-defined subprogram. 

Reason: Without this rule about generics, we would have to forbid instantiations in preelaborated library units, which would significantly reduce their usefulness. 

If a [pragma](S0016) Preelaborate (or [pragma](S0016) Pure - see below) applies to a library unit, then it is preelaborated. [ If a library unit is preelaborated, then its declaration, if any, and body, if any, are elaborated prior to all nonpreelaborated [library_item](S0216)s of the partition.] All compilation units of a preelaborated library unit shall be preelaborable. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. In addition, all compilation units of a preelaborated library unit shall depend semantically only on compilation units of other preelaborated library units. 

Ramification: In a generic body, we assume the worst about formal private types and extensions.




#### Implementation Advice

In an implementation, a type declared in a preelaborated package should have the same representation in every elaboration of a given version of the package, whether the elaborations occur in distinct executions of the same program, or in executions of distinct programs or partitions that include the given version. 

The form of a [pragma](S0016) Pure is as follows: 

  pragma Pure[(library_unit_[name](S0084))];

A [pragma](S0016) Pure is a library unit pragma. 


#### Legality Rules

A pure [library_item](S0216) is a preelaborable [library_item](S0216) that does not contain the declaration of any variable or named access within a subprogram, generic subprogram, task unit, or protected unit.

A [pragma](S0016) Pure is used to declare that a library unit is pure. If a [pragma](S0016) Pure applies to a library unit, then its compilation units shall be pure, and they shall depend semantically only on compilation units of other library units that are declared pure. 

To be honest: A declared-pure library unit is one to which a [pragma](S0016) Pure applies. Its declaration and body are also said to be declared pure. 

Discussion: A declared-pure package is useful for defining types to be shared between partitions with no common address space. 

Reason: Note that generic packages are not mentioned in the list of things that can contain variable declarations. Note that the Ada 95 rules for deferred constants make them allowable in library units that are declared pure; that isn't true of Ada 83's deferred constants. 

Ramification: Anonymous access types (that is, access discriminants and access parameters) are allowed.

Reason: The primary reason for disallowing named access types is that an [allocator](S0122) has a side effect; the pool constitutes variable data. We considered somehow allowing [allocator](S0122)-less access types. However, these (including access-to-subprogram types) would cause trouble for Annex E, "Distributed Systems", because such types would  allow access values in a shared passive partition to designate objects in an active partition, thus allowing inter-address space references.Furthermore, a named access-to-object type without a pool would be a new concept, adding complexity from the user's point of view. Finally, the prevention of [allocator](S0122)s would have to be a runtime check, in order to avoid violations of the generic contract model. 


#### Implementation Permissions

If a library unit is declared pure, then the implementation is permitted to omit a call on a library-level subprogram of the library unit if the results are not needed after the call. Similarly, it may omit such a call and simply reuse the results produced by an earlier call on the same subprogram, provided that none of the parameters are of a limited type, and the addresses and values of all by-reference actual parameters, and the values of all by-copy-in actual parameters, are the same as they were at the earlier call. [This permission applies even if the subprogram produces other side effects when called.] 

Discussion: A declared-pure [library_item](S0216) has no variable state. Hence, a call on one of its (nonnested) subprograms cannot "normally" have side effects. The only possible side effects from such a call would be through machine code insertions,unchecked conversion to an access type declared within the subprogram, and similar features. The compiler may omit a call to such a subprogram even if such side effects exist, so the writer of such a subprogram has to keep this in mind. 


#### Syntax

The form of a [pragma](S0016) Elaborate, Elaborate_All, or Elaborate_Body is as follows:: 

  pragma Elaborate(library_unit_[name](S0084){, library_unit_[name](S0084)});

  pragma Elaborate_All(library_unit_[name](S0084){, library_unit_[name](S0084)});

  pragma Elaborate_Body[(library_unit_[name](S0084));]

A [pragma](S0016) Elaborate or Elaborate_All is only allowed within a [context_clause](S0221). 

Ramification: "Within a [context_clause](S0221)" allows it to be the last item in the [context_clause](S0221). It can't be first, because the [name](S0084) has to denote something mentioned earlier. 

A [pragma](S0016) Elaborate_Body is a library unit pragma. 

Discussion: Hence, a [pragma](S0016) Elaborate or Elaborate_All is not elaborated, not that it makes any practical difference.

Note that a [pragma](S0016) Elaborate or Elaborate_All is neither a program unit pragma, nor a library unit pragma.


#### Legality Rules

If a [pragma](S0016) Elaborate_Body applies to a declaration, then the declaration requires a completion [(a body)].


#### Static Semantics

[A [pragma](S0016) Elaborate specifies that the body of the named library unit is elaborated before the current [library_item](S0216). A [pragma](S0016) Elaborate_All specifies that each [library_item](S0216) that is needed by the named library unit declaration is elaborated before the current [library_item](S0216). A [pragma](S0016) Elaborate_Body specifies that the body of the library unit is elaborated immediately after its declaration.]

Proof: The official statement of the semantics of these [pragma](S0016)s is given in 10.2. 

Implementation Note: The presence of a [pragma](S0016) Elaborate_Body simplifies the removal of unnecessary Elaboration_Checks. For a subprogram declared immediately within a library unit to which a [pragma](S0016) Elaborate_Body applies, the only calls that can fail the Elaboration_Check are those that occur in the library unit itself, between the declaration and body of the called subprogram; if there are no such calls (which can easily be detected at compile time if there are no stubs), then no Elaboration_Checks are needed for that subprogram. The same is true for Elaboration_Checks on task activations and instantiations, and for library subprograms and generic units. 

Ramification: The fact that the unit of elaboration is the [library_item](S0216) means that if a [subprogram_body](S0154) is not a completion, it is impossible for any [library_item](S0216) to be elaborated between the declaration and the body of such a subprogram. Therefore, it is impossible for a call to such a subprogram to fail its Elaboration_Check. 

Discussion: The visibility rules imply that each library_unit_[name](S0084) of a [pragma](S0016) Elaborate or Elaborate_All has to denote a library unit mentioned by a previous [with_clause](S0223) of the same [context_clause](S0221). 

NOTE 1   A preelaborated library unit is allowed to have nonpreelaborable children. 

Ramification: But not nonpreelaborated subunits. 

NOTE 2   A library unit that is declared pure is allowed to have impure children. 

Ramification: But not impure subunits. 

Ramification: Pragma Elaborate is mainly for closely related library units, such as when two package bodies 'with' each other's declarations. In such cases, Elaborate_All sometimes won't work. 


#### Extensions to Ada 83

The concepts of preelaborability and purity are new to Ada 95. The Elaborate_All, Elaborate_Body, Preelaborate, and Pure [pragma](S0016)s are new to Ada 95.

Pragmas Elaborate are allowed to be mixed in with the other things in the [context_clause](S0221) - in Ada 83, they were required to appear last. 

