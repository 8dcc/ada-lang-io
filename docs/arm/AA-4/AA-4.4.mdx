---
sidebar_position:  32
---

# 4.4 Expressions

:::warning
We're still working on the Reference manual output.  Internal links are broken,
as are a bunch of other things.
See the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

<p>{"{"}<em>{"AI05-0147-1"}</em>{"}"} {"{"}<em>{"AI05-0158-1"}</em>{"}"} {"{"}<em>{"AI05-0176-1"}</em>{"}"} An <em>expression</em> is a formula that defines the computation or retrieval of a value. In this Reference Manual, the term "expression" refers to a construct of the syntactic category <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> or of any of the following categories: <code><a href="../AA-4/AA-4.4#S0133">choice_expression</a></code>, <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>, <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>, <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>, <code><a href="../AA-4/AA-4.4#S0139">term</a></code>, <code><a href="../AA-4/AA-4.4#S0140">factor</a></code>, <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>, <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code>, <code><a href="../AA-4/AA-4.5#S0153">quantified_expression</a></code>. </p>

#### Syntax

<p><code>expression</code><a id="S0132"></a><code> ::= </code>     <code><a href="../AA-4/AA-4.4#S0135">relation</a></code> {"{"}<strong>and</strong> <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>{"}"} 	| <code><a href="../AA-4/AA-4.4#S0135">relation</a></code> {"{"}<strong>and</strong> <strong>then</strong> <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0135">relation</a></code> {"{"}<strong>or</strong> <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>{"}"} 	| <code><a href="../AA-4/AA-4.4#S0135">relation</a></code> {"{"}<strong>or</strong> <strong>else</strong> <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0135">relation</a></code> {"{"}<strong>xor</strong> <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>{"}"}</p>
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} <code>choice_expression</code><a id="S0133"></a><code> ::= </code>     <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code> {"{"}<strong>and</strong> <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code> {"{"}<strong>or</strong> <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code> {"{"}<strong>xor</strong> <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code> {"{"}<strong>and then</strong> <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>{"}"}   | <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code> {"{"}<strong>or else</strong> <code><a href="../AA-4/AA-4.4#S0134">choice_relation</a></code>{"}"}</p>
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} <code>choice_relation</code><a id="S0134"></a><code> ::= </code>     <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> [<code><a href="../AA-4/AA-4.5#S0143">relational_operator</a></code> <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>]</p>
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} {"{"}<em>{"AI12-0022-1"}</em>{"}"} {"{"}<em>{"AI12-0039-1"}</em>{"}"} <code>relation</code><a id="S0135"></a><code> ::= </code>     <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> [<code><a href="../AA-4/AA-4.5#S0143">relational_operator</a></code> <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>]   | <em>tested_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> [<strong>not</strong>] <strong>in</strong> <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code>   | <code><a href="../AA-11/AA-11.3#S0309">raise_expression</a></code></p>
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} {"{"}<em>{"AI12-0212-1"}</em>{"}"} <code>membership_choice_list</code><a id="S0136"></a><code> ::= </code><code><a href="../AA-4/AA-4.4#S0137">membership_choice</a></code> {"{"}'|' <code><a href="../AA-4/AA-4.4#S0137">membership_choice</a></code>{"}"}</p>
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} {"{"}<em>{"AI12-0039-1"}</em>{"}"} <code>membership_choice</code><a id="S0137"></a><code> ::= </code><em>choice_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> | <code><a href="../AA-3/AA-3.5#S0037">range</a></code> | <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code></p>
<p><code>simple_expression</code><a id="S0138"></a><code> ::= </code>[<code><a href="../AA-4/AA-4.5#S0145">unary_adding_operator</a></code>] <code><a href="../AA-4/AA-4.4#S0139">term</a></code> {"{"}<code><a href="../AA-4/AA-4.5#S0144">binary_adding_operator</a></code> <code><a href="../AA-4/AA-4.4#S0139">term</a></code>{"}"}</p>
<p><code>term</code><a id="S0139"></a><code> ::= </code><code><a href="../AA-4/AA-4.4#S0140">factor</a></code> {"{"}<code><a href="../AA-4/AA-4.5#S0146">multiplying_operator</a></code> <code><a href="../AA-4/AA-4.4#S0140">factor</a></code>{"}"}</p>
<p><code>factor</code><a id="S0140"></a><code> ::= </code><code><a href="../AA-4/AA-4.4#S0141">primary</a></code> [** <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>] | <strong>abs</strong> <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> | <strong>not</strong> <code><a href="../AA-4/AA-4.4#S0141">primary</a></code></p>
<p>{"{"}<em>{"AI05-0003-1"}</em>{"}"} {"{"}<em>{"AI05-0147-1"}</em>{"}"} {"{"}<em>{"AI05-0176-1"}</em>{"}"} {"{"}<em>{"AI12-0236-1"}</em>{"}"} <code>primary</code><a id="S0141"></a><code> ::= </code>    <code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code> | <strong>null</strong> | <code><a href="../AA-2/AA-2.6#S0016">string_literal</a></code> | <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>  | <code><a href="../AA-4/AA-4.1#S0091">name</a></code> | <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> | (<code><a href="../AA-4/AA-4.4#S0132">expression</a></code>)  | (<code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code>) | (<code><a href="../AA-4/AA-4.5#S0153">quantified_expression</a></code>)  | (<code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code>)</p>

#### Name Resolution Rules

<p>A <code><a href="../AA-4/AA-4.1#S0091">name</a></code> used as a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> shall resolve to denote an object or a value. </p>
<Admonition type="note">
<p><strong>Discussion: </strong>This replaces RM83-4.4(3). We don't need to mention named numbers explicitly, because the name of a named number denotes a value. We don't need to mention attributes explicitly, because attributes now denote (rather than yield) values in general. Also, the new wording allows attributes that denote objects, which should always have been allowed (in case the implementation chose to have such a thing). </p></Admonition>

<Admonition type="note">
<p><strong>Reason: </strong>It might seem odd that this is an overload resolution rule, but it is relevant during overload resolution. For example, it helps ensure that a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that consists of only the identifier of a parameterless function is interpreted as a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> rather than directly as a <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code>. </p></Admonition>


#### Static Semantics

<p>Each expression has a type; it specifies the computation or retrieval of a value of that type.</p>
<p>{"{"}<em>{"AI12-0317-1"}</em>{"}"} A <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that is an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> surrounded by ( and ) is known as a <em>parenthesized expression</em>.</p>
<p>{"{"}<em>{"AI12-0317-1"}</em>{"}"} Every <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> consists of one or more <em>operative constituent</em> <code><a href="../AA-4/AA-4.1#S0091">name</a></code>s or <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s, only one of which is evaluated as part of evaluating the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> (the <em>evaluated operative constituent</em>). The operative constituents are determined as follows, according to the form of the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> (or <code><a href="../AA-4/AA-4.1#S0091">name</a></code>):</p>
<p>if the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> is a <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code>, the operative constituents of its <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s;</p>
<p>if the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> (or <code><a href="../AA-4/AA-4.1#S0091">name</a></code>) is a parenthesized expression, a <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code>, or a view conversion, the operative constituent(s) of its operand;</p>
<p>if the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> is a <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code>, the operative constituent(s) of its <em>body_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>;</p>
<p>otherwise, the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> (or <code><a href="../AA-4/AA-4.1#S0091">name</a></code>) itself. </p>
<p>{"{"}<em>{"AI12-0317-1"}</em>{"}"} In certain contexts, we specify that an operative constituent shall (or shall not) be <em>newly constructed</em>. This means the operative constituent shall (or shall not) be an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>; in either case, a <code><a href="../AA-11/AA-11.3#S0309">raise_expression</a></code> is permitted.</p>
<Admonition type="note">
<p><strong>To be honest: </strong>If an <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code> does not have an <strong>else</strong> clause, "True" is an operative constituent of the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> and it can be the evaluated operative constituent. </p></Admonition>


#### Dynamic Semantics

<p>The value of a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that is a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> denoting an object is the value of the object.</p>
<p>{"{"}<em>{"AI12-0227-1"}</em>{"}"} An expression of a numeric universal type is evaluated as if it has type <em>root_integer</em> (for <em>universal_integer</em>) or <em>root_real</em> (otherwise) unless the context identifies a specific type (in which case that type is used).</p>
<Admonition type="note">
<p><strong>Ramification: </strong>This has no effect for a static expression; its value may be arbitrarily small or large since no specific type is expected for any expression for which this rule specifies one of the root types. The only effect of this rule is to allow Constraint_Error to be raised if the value is outside of the base range of <em>root_integer</em> or <em>root_real</em> when the expression is not static. </p></Admonition>

<Admonition type="note">
<p><strong>Reason: </strong>This rule means that implementations don't have to support unlimited range math at run time for universal expressions. Note that universal expressions for which the context doesn't specify a specific type are quite rare; attribute prefixes and results are the only known cases. (For operators, 8.6 already specifies that the operator of a root type be used, which provides a specific type.) </p></Admonition>


#### Implementation Permissions

<p>For the evaluation of a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that is a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> denoting an object of an unconstrained numeric subtype, if the value of the object is outside the base range of its type, the implementation may either raise Constraint_Error or return the value of the object. </p>
<Admonition type="note">
<p><strong>Ramification: </strong>{"{"}<em>{"AI05-0299-1"}</em>{"}"} This means that if extra-range intermediates are used to hold the value of an object of an unconstrained numeric subtype, a Constraint_Error can be raised on a read of the object, rather than only on an assignment to it. Similarly, it means that computing the value of an object of such a subtype can be deferred until the first read of the object (presuming no side effects other than failing an Overflow_Check are possible). This permission is over and above that provided by subclause 11.6, since this allows the Constraint_Error to move to a different handler. </p></Admonition>

<Admonition type="note">
<p><strong>Reason: </strong>This permission is intended to allow extra-range registers to be used efficiently to hold parameters and local variables, even if they might need to be transferred into smaller registers for performing certain predefined operations. </p></Admonition>

<Admonition type="note">
<p><strong>Discussion: </strong>There is no need to mention other kinds of <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>s, since any Constraint_Error to be raised can be "charged" to the evaluation of the particular kind of <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>. </p></Admonition>


#### Examples

<p><em>Examples of primaries:</em> </p>
<CodeBlock>
4.0                --  real literal{"\n"}Pi                 --  named number{"\n"}(1 .. 10 ={">"} 0)     --  array aggregate{"\n"}Sum                --  variable{"\n"}Integer'Last       --  attribute{"\n"}Sine(X)            --  function call{"\n"}Color'(Blue)       --  qualified expression{"\n"}Real(M*N)          --  conversion{"\n"}(Line_Count + 10)  --  parenthesized expression {"\n"}
</CodeBlock>

<p><em>Examples of expressions:</em> </p>
<CodeBlock>
{"{"}{"AI95-00433-01"}{"}"} Volume                      -- primary{"\n"}not Destroyed               -- factor{"\n"}2*Line_Count                -- term{"\n"}-4.0                        -- simple expression{"\n"}-4.0 + A                    -- simple expression{"\n"}B**2 - 4.0*A*C              -- simple expression{"\n"}R*Sin()*Cos()             -- simple expression{"\n"}Password(1 .. 3) = "Bwv"    -- relation{"\n"}Count in Small_Int          -- relation{"\n"}Count not in Small_Int      -- relation{"\n"}Index = 0 or Item_Hit       -- expression{"\n"}(Cold and Sunny) or Warm    -- expression (parentheses are required){"\n"}A**(B**C)                   -- expression (parentheses are required){"\n"}
</CodeBlock>


#### Extensions to Ada 83

<Admonition type="note">
<p>In Ada 83, <strong>out</strong> parameters and their nondiscriminant subcomponents are not allowed as <code>primaries</code>. These restrictions are eliminated in Ada 95.</p></Admonition>

<Admonition type="note">
<p>In various contexts throughout the language where Ada 83 syntax rules had <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>, the corresponding Ada 95 syntax rule has <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> instead. This reflects the inclusion of modular integer types, which makes the logical operators "<strong>and</strong>", "<strong>or</strong>", and "<strong>xor</strong>" more useful in expressions of an integer type. Requiring parentheses to use these operators in such contexts seemed unnecessary and potentially confusing. Note that the bounds of a <code><a href="../AA-3/AA-3.5#S0037">range</a></code> still have to be specified by <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>s, since otherwise <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s involving membership tests might be ambiguous. Essentially, the operation ".." is of higher precedence than the logical operators, and hence uses of logical operators still have to be parenthesized when used in a bound of a range. </p></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="note">
<p>{"{"}<em>{"AI05-0003-1"}</em>{"}"} Moved <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code> from <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> to <code><a href="../AA-4/AA-4.1#S0091">name</a></code> (see 4.1). This allows the use of <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code>s in more places.</p></Admonition>

<Admonition type="note">
<p>{"{"}<em>{"AI05-0147-1"}</em>{"}"} {"{"}<em>{"AI05-0176-1"}</em>{"}"} Added <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code> and <code><a href="../AA-4/AA-4.5#S0153">quantified_expression</a></code> to <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>.</p></Admonition>

<Admonition type="note">
<p>{"{"}<em>{"AI05-0158-1"}</em>{"}"} Expanded membership test syntax (see 4.5.2). </p></Admonition>


#### Inconsistencies With Ada 2012

<Admonition type="note">
<p>{"{"}<em>{"AI12-0039-1"}</em>{"}"} <strong>Corrigendum:</strong> Revised membership syntax to eliminate ambiguities. In some cases, previously ambiguous membership expressions will now have an unambiguous meaning. If an Ada 2012 implementation chose the "wrong" meaning, the expression could silently change meaning. Virtually all such expressions will become illegal because of type mismatches (and thus be incompatible, not inconsistent). However, if the choices are all of a Boolean type, resolution might succeed. For instance, A <strong>in</strong> B | C <strong>and</strong> D now always means (A <strong>in</strong> B | C) <strong>and</strong> D, but the original Ada 2012 syntax would have allowed it to mean A <strong>in</strong> B | (C <strong>and</strong> D). If a compiler allowed the expression and interpreted it as the latter, the meaning of the expression would silently change. We expect this to be extremely rare as membership operations on Boolean types are unlikely (and this can happen only in code written for Ada 2012). </p></Admonition>


#### Incompatibilities With Ada 2012

<Admonition type="note">
<p>{"{"}<em>{"AI12-0039-1"}</em>{"}"} <strong>Corrigendum:</strong> The revised membership syntax will require parentheses in <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code>s in some cases where the Ada 2012 grammar did not require them. For instance, A <strong>in</strong> B <strong>in</strong> C | D is now illegal. However, such expressions can be interpreted in multiple ways (either A <strong>in</strong> (B <strong>in</strong> C) | D or A <strong>in</strong> (B <strong>in</strong> C | D) for this example), so using such expressions is likely to be dangerous (another compiler might interpret the expression differently). In addition, all such expressions occur only in Ada 2012 syntax; so they should be rare. </p></Admonition>


#### Wording Changes from Ada 2012

<Admonition type="note">
<p>{"{"}<em>{"AI12-0227-1"}</em>{"}"} <strong>Correction:</strong> Added wording so that universal expressions evaluated at run time can raise Constraint_Error if the value is outside of the range of <em>root_integer</em> or <em>root_real</em>. We don't document this as an inconsistency because the rule requires no implementation to change (as Constraint_Error is not required); it just allows implementations that already raise Constraint_Error (which is all of them surveyed) to be considered correct.</p></Admonition>

<Admonition type="note">
<p>{"{"}<em>{"AI12-0236-1"}</em>{"}"} Added <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code> to <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>. It shares the rules about parentheses with <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code>s.</p></Admonition>

<Admonition type="note">
<p>{"{"}<em>{"AI12-0317-1"}</em>{"}"} Added the definitions of "operative constituent" and "newly constructed" to centralize definitions that are needed for various rules and definitions across the Reference Manual. In particular, <em>operative constituent</em> is often used when we want the semantics or legality to be unchanged by the presence of parens, qualification, or view conversions. Examples are found in 4.3.2, 6.2, and 7.5. </p></Admonition>

